{
    "docs": [
        {
            "location": "/", 
            "text": "DifferentialEquations.jl Documentation\n\n\nDifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications. It integrates with the Julia package sphere, for example using Juno's progress meter, and wraps other differential equation solvers so that many different methods for solving the equations can be accessed by simply switching a keyword argument.\n\n\nAll of the algorithms are thoroughly tested to ensure accuracy. Convergence tests are included in the \ntest/\n folder. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. Example IJulia notebooks \ncan be found in the examples folder\n. If you find any example where there seems to be an error, please open an issue.\n\n\nIf you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the \nGitter channel\n. For bug reports, feature requests, etc., please submit an issue. If you're interested in contributing, please see the \nContributor's Guide\n.\n\n\n\n\nUsing the Package\n\n\nTo install the package, use the following command inside the Julia REPL:\n\n\nPkg.add(\nDifferentialEquations\n)\n\n\n\n\nFor all of the latest features, switch to the master branch via:\n\n\nPkg.checkout(\nDifferentialEquations\n)\n\n\n\n\nTo load the package, use the command:\n\n\nusing DifferentialEquations\n\n\n\n\nTo understand the package in more detail, check out the following tutorials in the manual. Examples IJulia notebooks using DifferentialEquations can be found \nin the examples folder\n. Codes for the latest features can be found in \ntest/\n.\n\n\nFor the most up to date on using the package information, please contact me \nvia the repository Gitter\n or \nread the latest documentation\n\n\n\n\nSupported Equations\n\n\nFor PDEs, one can optionally specify a noise equation. The solvers currently have stochastic variants for handling Gaussian Space-time white noise SPDEs.\n\n\n\n\nODEs\n\n\nSODEs\n\n\n\n\n(Stochastic) PDEs\n\n\n\n\nLinear Poisson Equation\n\n\nSemi-linear Poisson Equation\n\n\nLinear Heat Equation\n\n\nSemi-linear Heat Equation (aka Reaction-Diffusion Equation)\n\n\nStationary Stokes Equation\n\n\n\n\n\n\n\n\n\n\nImplemented Solvers\n\n\nFor help with choosing a solver algorithm, please see the solver options pages.\n\n\nFor PDEs, [method] denotes an additional version for handling stochastic partial differential equations. SDE solvers and ODE solvers take in general sized inputs. For example, if u\u2080 is a matrix (and your problem functions are designed to work with matrices), then the solver will use the matrices without error.\n\n\n\n\n\n\nODEs\n\n\n\n\n\n\nOptimized Explicit Runge-Kutta Methods\n\n\n\n\nEuler - The Order 1 Euler Method\n\n\nMidpoint - The Order 2 Midpoint Method\n\n\nRK4 - The classic Runge-Kutta Order 4 Method\n\n\nBS3 - Bogacki-Shampine 2/3\n\n\nDP5 - Dormand-Prince 4/5\n\n\nTsit5 - Tsitouras 4/5\n\n\nBS5 - Bogacki-Shampine 4/5\n\n\nVern6 - Verner's \"Most Efficient\" 5/6\n\n\nTanYam7 - Tanaka-Yamashita 7\n\n\nDP8 - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method\n\n\nTsitPap8 - Tsitouras-Papakostas 8/7\n\n\nVern9 - Verner's \"Most Efficient\" 9/8\n\n\nFeagin10 - Feagin's Order 10/8 Method\n\n\nFeagin12 - Feagin's Order 12/10 Method\n\n\n\n\nFeagin14 - Feagin's Order 14/12 Method\n\n\n\n\nGeneral Explicit (Adaptive) Runge-Kutta Methods\n\n\n\n\n\n\n\n\nThese solvers are defined by tableaus. For a list of pre-defined tableaus, see \nthe ODE Solver options\n.\n\n\n\n\nStiff Solvers. Requires \nNLsolve.jl\n. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\nImplicit Euler\n\n\n\n\nTrapezoidal\n\n\n\n\nRosenbrock32\n\n\n\n\nWrappers for ODEInterface.jl. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\ndorpi5 - Hairer's DP5(4)\n\n\n\n\ndop853 - Hairer's DP8(5,3)\n\n\nodex - Extrapolation algorithm based on explicit midpoint rule\n\n\nradau5 - Implicit Runge-Kutta order 5\n\n\nradau - Implicit Runge-Kutta variable order 5-13\n\n\n\n\nseulex - Extrapolation based on linear implicit Euler\n\n\n\n\nWrappers for ODE.jl. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\node23 - Bogacki-Shampine's method\n\n\n\n\node45 - Dormand-Prince  4/5\n\n\node78 - Runge-Kutta-Fehlberg  7/8\n\n\node23s - Rosenbrock method 2/3\n\n\node1 - Forward Euler\n\n\nmidpoint - Midpoint method\n\n\node2_heun - Huen's method\n\n\node4 - RK4\n\n\n\n\node45_fe - Runge-Kutta-Fehlberg 4/5\n\n\n\n\nWrappers for Sundials.jl. See \nConditional Dependences\n.\n\n\n\n\n\n\n\n\ncvode_BDF - The Lawrence Livermore CVODE BDF solver.\n\n\n\n\ncvode_Adams - The Lawrence Livermore CVODE BDF solver Adams-Moulton solver.\n\n\n\n\n\n\n\n\n\n\n\n\nSODEs\n\n\n\n\nEuler-Maruyama\n\n\nMilstein\n\n\nRossler-SRK\n\n\n\n\n\n\n\n\nFinite Element Solvers (Stochastic) PDEs\n\n\n\n\n\n\nSemilinear Poisson Equation\n\n\n\n\n\n\nSee implicit solvers\n\n\n\n\nSemilinear Heat Equation (Reaction-Diffusion)\n\n\n\n\n\n\n\n\nForward Euler [Maruyama]\n\n\n\n\nBackward Euler [Maruyama]\n\n\nSemi-implicit Crank-Nicholson [Maruyama]\n\n\n\n\nSemi-implicit Backward Euler [Maruyama]\n\n\n\n\nLinear Heat Equation\n\n\n\n\n\n\n\n\nForward Euler [Maruyama]\n\n\n\n\nBackward Euler [Maruyama]\n\n\nCrank-Nicholson [Maruyama]\n\n\n\n\n\n\n\n\n\n\n\n\nImplicit Solvers\n\n\n\n\nDirect\n\n\nFactorizations (LU, Cholesky, QR, SVD)\n\n\nConjugate-Gradient (CG)\n\n\nGMRES\n\n\n\n\n\n\n\n\n\n\nRoadmap\n\n\n\n\n\n\nODE Solvers\n\n\n\n\nStabilized stiff - ROCK2 and ROCK4\n\n\n\n\nSODE Solvers\n\n\n\n\n\n\nAdaptive-SRK\n\n\n\n\n\n\nFinite difference solvers\n\n\n\n\n\n\nSemi-linear Heat Equation (Reaction-Diffusion Equation)\n\n\n\n\nSemi-linear Poisson Equation\n\n\nWave Equation\n\n\nTransport Equation\n\n\n\n\nStochastic PDE Solvers\n\n\n\n\n\n\nImplicit Integration Factor (IIF) Maruyama\n\n\n\n\nImplicit Integration Factor (IIF) Milstein\n\n\n\n\nDDE Solvers\n\n\n\n\n\n\nWrap RETARD and RADAR5\n\n\n\n\nImplement standard Runge-Kutta DDE solvers\n\n\n\n\nAlgebraic differential equations\n\n\n\n\n\n\nImplement standard solvers and add to ODEProblem type\n\n\n\n\n\n\nLinear Solvers\n\n\n\n\n\n\nFinite Difference Geometric Multigrids\n\n\n\n\nAlgebraic Multigrids via pyAMG\n\n\n\n\nPerformance\n\n\n\n\n\n\nImprove FEM performance\n\n\n\n\nImplement threaded versions\n\n\nTest ParallelAccelerator.jl on solvers\n\n\nAdd Xeon Phi / GPU variants\n\n\n\n\nMisc\n\n\n\n\n\n\nDavie-Gaines convergence analysis\n\n\n\n\nAdd benchmarking tools\n\n\nImprove MonteCarloSimulation\n\n\n\n\n\n\n\n\n\n\nIJulia Notebook Tutorials\n\n\nIf you have \nIJulia\n installed, you can access extra tutorials in the supplied IJulia notebooks via:\n\n\nusing IJulia\ncd(Pkg.dir(\nDifferentialEquations\n)*\n/examples\n)\nnotebook()\n\n\n\n\nOtherwise, these notebooks can be viewed \nvia the Github repository\n (note that Github renders them slightly incorrectly, so it will look better in IJulia!).\n\n\n\n\nTutorials\n\n\nThe following tutorials will introduce you to the functionality of DifferentialEquations.jl More examples can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\n\n\nOrdinary Differential Equation (ODE) Example\n\n\nStochastic Differential Equation (SDE) Example\n\n\nPoisson Equation Finite Element Method Example\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\n\n\n\n\nSolver Options\n\n\nThese pages describe the options available in the solvers.\n\n\n\n\nOrdinary Differential Equation Solvers\n\n\nRecommended Methods\n\n\nFull List of Methods\n\n\nList of Supplied Tableaus\n\n\nAnalysis of Methods\n\n\n\n\n\n\nStochastic Differential Equation Solvers\n\n\nFinite Element Method Poisson Equation Solvers\n\n\nFinite Element Method Heat Equation Solvers\n\n\n\n\n\n\nFinite Difference Method Stokes Equation Solvers\n\n\nStokes Equation\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\n\nPlot Functions\n\n\nStandard Plots\n\n\nExtra Plot Functions\n\n\n\n\n\n\nDefining a FEM Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nInternal Finite Element Tools\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nFinite Element Method Poisson Equation Solvers\n\n\nMeshes\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\nExample Meshes\n\n\nPlot Functions\n\n\n\n\n\n\nJuno Progress Bar Integration\n\n\nConditional Dependencies\n\n\nThe Conditional Dependency Notification\n\n\nWhat Methods Require Conditional Dependencies?\n\n\nInstallation Instructions\n\n\n\n\n\n\nThe Solution Type\n\n\nSolution Types\n\n\nRelated Functions\n\n\n\n\n\n\nFinite Difference Method Stokes Equation Solvers\n\n\nStokes Equation\n\n\n\n\n\n\nOrdinary Differential Equation (ODE) Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\nDefining a Stokes Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nContributor's Guide\n\n\nDeveloping New Solver Algorithms\n\n\nAdding Conditional Dependencies\n\n\nDeveloping A New Problem\n\n\nOther Help\n\n\n\n\n\n\nDefining a SDE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nExtras for Developers and Researchers\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Differential Equation (SDE) Example\n\n\nFinite Element Method Heat Equation Solvers\n\n\n\n\n\n\nSolver Helpers\n\n\nODE Solver Extras\n\n\nSDE Solver Extras\n\n\nStationary Stokes\n\n\n\n\n\n\nStochastic Differential Equation Solvers\n\n\nPoisson Equation Finite Element Method Example\n\n\nDefining an ODE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nNotes on Algorithms\n\n\nExplicit Runge-Kutta ODE Algorithms\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\nOrdinary Differential Equation Solvers\n\n\nRecommended Methods\n\n\nFull List of Methods\n\n\nList of Supplied Tableaus\n\n\nAnalysis of Methods\n\n\n\n\n\n\nExtra Functions\n\n\nDifferentialEquations.jl Documentation\n\n\nUsing the Package\n\n\nSupported Equations\n\n\nImplemented Solvers\n\n\nRoadmap\n\n\nIJulia Notebook Tutorials\n\n\nTutorials\n\n\nSolver Options\n\n\nManual\n\n\nInternal Documentation\n\n\nIndex\n\n\n\n\n\n\n\n\n\n\nInternal Documentation\n\n\n\n\nPlot Functions\n\n\nStandard Plots\n\n\nExtra Plot Functions\n\n\n\n\n\n\nDefining a FEM Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nInternal Finite Element Tools\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nFinite Element Method Poisson Equation Solvers\n\n\nMeshes\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\nExample Meshes\n\n\nPlot Functions\n\n\n\n\n\n\nJuno Progress Bar Integration\n\n\nConditional Dependencies\n\n\nThe Conditional Dependency Notification\n\n\nWhat Methods Require Conditional Dependencies?\n\n\nInstallation Instructions\n\n\n\n\n\n\nThe Solution Type\n\n\nSolution Types\n\n\nRelated Functions\n\n\n\n\n\n\nFinite Difference Method Stokes Equation Solvers\n\n\nStokes Equation\n\n\n\n\n\n\nOrdinary Differential Equation (ODE) Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\nDefining a Stokes Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nContributor's Guide\n\n\nDeveloping New Solver Algorithms\n\n\nAdding Conditional Dependencies\n\n\nDeveloping A New Problem\n\n\nOther Help\n\n\n\n\n\n\nDefining a SDE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nExtras for Developers and Researchers\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Differential Equation (SDE) Example\n\n\nFinite Element Method Heat Equation Solvers\n\n\n\n\n\n\nSolver Helpers\n\n\nODE Solver Extras\n\n\nSDE Solver Extras\n\n\nStationary Stokes\n\n\n\n\n\n\nStochastic Differential Equation Solvers\n\n\nPoisson Equation Finite Element Method Example\n\n\nDefining an ODE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nNotes on Algorithms\n\n\nExplicit Runge-Kutta ODE Algorithms\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\nOrdinary Differential Equation Solvers\n\n\nRecommended Methods\n\n\nFull List of Methods\n\n\nList of Supplied Tableaus\n\n\nAnalysis of Methods\n\n\n\n\n\n\nExtra Functions\n\n\nDifferentialEquations.jl Documentation\n\n\nUsing the Package\n\n\nSupported Equations\n\n\nImplemented Solvers\n\n\nRoadmap\n\n\nIJulia Notebook Tutorials\n\n\nTutorials\n\n\nSolver Options\n\n\nManual\n\n\nInternal Documentation\n\n\nIndex\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDifferentialEquations.ODE_DEFAULT_TABLEAU\n\n\nDifferentialEquations.ConvergenceSimulation\n\n\nDifferentialEquations.DEProblem\n\n\nDifferentialEquations.DESolution\n\n\nDifferentialEquations.ExplicitRKTableau\n\n\nDifferentialEquations.FEMSolution\n\n\nDifferentialEquations.FEMmesh\n\n\nDifferentialEquations.HeatProblem\n\n\nDifferentialEquations.Mesh\n\n\nDifferentialEquations.ODEProblem\n\n\nDifferentialEquations.ODESolution\n\n\nDifferentialEquations.PoissonProblem\n\n\nDifferentialEquations.RosslerSRA\n\n\nDifferentialEquations.RosslerSRI\n\n\nDifferentialEquations.SDEProblem\n\n\nDifferentialEquations.SDESolution\n\n\nDifferentialEquations.SimpleMesh\n\n\nDifferentialEquations.StokesProblem\n\n\nDifferentialEquations.StokesSolution\n\n\nDifferentialEquations.Tableau\n\n\nBase.length\n\n\nBase.length\n\n\nDifferentialEquations.CFL\u03bc\n\n\nDifferentialEquations.CFL\u03bd\n\n\nDifferentialEquations.FEMSolutionTS\n\n\nDifferentialEquations.GSu!\n\n\nDifferentialEquations.GSv!\n\n\nDifferentialEquations.GS\u03b4q!\n\n\nDifferentialEquations.additiveSDEExample\n\n\nDifferentialEquations.animate\n\n\nDifferentialEquations.appxTrue!\n\n\nDifferentialEquations.assemblematrix\n\n\nDifferentialEquations.calc_rp!\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n\n\nDifferentialEquations.checkSRAOrder\n\n\nDifferentialEquations.checkSRIOrder\n\n\nDifferentialEquations.constructCashKarp\n\n\nDifferentialEquations.constructDormandPrince\n\n\nDifferentialEquations.constructDormandPrince8\n\n\nDifferentialEquations.constructHuen\n\n\nDifferentialEquations.constructRKF8\n\n\nDifferentialEquations.constructRalston\n\n\nDifferentialEquations.constructSRA1\n\n\nDifferentialEquations.constructSRIW1\n\n\nDifferentialEquations.cubicSDEExample\n\n\nDifferentialEquations.dirichletzeroStokesExample\n\n\nDifferentialEquations.fem_squaremesh\n\n\nDifferentialEquations.findboundary\n\n\nDifferentialEquations.getH1error\n\n\nDifferentialEquations.getL2error\n\n\nDifferentialEquations.getNoise\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n\n\nDifferentialEquations.heatProblemExample_diffuse\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n\n\nDifferentialEquations.heatProblemExample_grayscott\n\n\nDifferentialEquations.heatProblemExample_moving\n\n\nDifferentialEquations.heatProblemExample_pure\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n\n\nDifferentialEquations.homogeneousStokesExample\n\n\nDifferentialEquations.linearODEExample\n\n\nDifferentialEquations.linearSDEExample\n\n\nDifferentialEquations.meshExample_Lshapemesh\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n\n\nDifferentialEquations.meshExample_bunny\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n\n\nDifferentialEquations.meshExample_lakemesh\n\n\nDifferentialEquations.meshExample_oilpump\n\n\nDifferentialEquations.meshExample_wavymesh\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n\n\nDifferentialEquations.monteCarloSim\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n\n\nDifferentialEquations.notime_squaremesh\n\n\nDifferentialEquations.numparameters\n\n\nDifferentialEquations.parabolic_squaremesh\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n\n\nDifferentialEquations.poissonProblemExample_wave\n\n\nDifferentialEquations.quadfbasis\n\n\nDifferentialEquations.quadpts\n\n\nDifferentialEquations.quadpts1\n\n\nDifferentialEquations.setboundary\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.stokes_prolongation\n\n\nDifferentialEquations.stokes_restriction\n\n\nDifferentialEquations.test_convergence\n\n\nDifferentialEquations.twoDimlinearODEExample\n\n\nDifferentialEquations.twoDimlinearSDEExample\n\n\nDifferentialEquations.update_p!\n\n\nDifferentialEquations.update_u!\n\n\nDifferentialEquations.update_v!\n\n\nDifferentialEquations.uzawa_p!\n\n\nDifferentialEquations.waveSDEExample\n\n\nDifferentialEquations.\u2207basis\n\n\nDifferentialEquations.\u2207u", 
            "title": "Introduction"
        }, 
        {
            "location": "/#differentialequationsjl-documentation", 
            "text": "DifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications. It integrates with the Julia package sphere, for example using Juno's progress meter, and wraps other differential equation solvers so that many different methods for solving the equations can be accessed by simply switching a keyword argument.  All of the algorithms are thoroughly tested to ensure accuracy. Convergence tests are included in the  test/  folder. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. Example IJulia notebooks  can be found in the examples folder . If you find any example where there seems to be an error, please open an issue.  If you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the  Gitter channel . For bug reports, feature requests, etc., please submit an issue. If you're interested in contributing, please see the  Contributor's Guide .", 
            "title": "DifferentialEquations.jl Documentation"
        }, 
        {
            "location": "/#using-the-package", 
            "text": "To install the package, use the following command inside the Julia REPL:  Pkg.add( DifferentialEquations )  For all of the latest features, switch to the master branch via:  Pkg.checkout( DifferentialEquations )  To load the package, use the command:  using DifferentialEquations  To understand the package in more detail, check out the following tutorials in the manual. Examples IJulia notebooks using DifferentialEquations can be found  in the examples folder . Codes for the latest features can be found in  test/ .  For the most up to date on using the package information, please contact me  via the repository Gitter  or  read the latest documentation", 
            "title": "Using the Package"
        }, 
        {
            "location": "/#supported-equations", 
            "text": "For PDEs, one can optionally specify a noise equation. The solvers currently have stochastic variants for handling Gaussian Space-time white noise SPDEs.   ODEs  SODEs   (Stochastic) PDEs   Linear Poisson Equation  Semi-linear Poisson Equation  Linear Heat Equation  Semi-linear Heat Equation (aka Reaction-Diffusion Equation)  Stationary Stokes Equation", 
            "title": "Supported Equations"
        }, 
        {
            "location": "/#implemented-solvers", 
            "text": "For help with choosing a solver algorithm, please see the solver options pages.  For PDEs, [method] denotes an additional version for handling stochastic partial differential equations. SDE solvers and ODE solvers take in general sized inputs. For example, if u\u2080 is a matrix (and your problem functions are designed to work with matrices), then the solver will use the matrices without error.    ODEs    Optimized Explicit Runge-Kutta Methods   Euler - The Order 1 Euler Method  Midpoint - The Order 2 Midpoint Method  RK4 - The classic Runge-Kutta Order 4 Method  BS3 - Bogacki-Shampine 2/3  DP5 - Dormand-Prince 4/5  Tsit5 - Tsitouras 4/5  BS5 - Bogacki-Shampine 4/5  Vern6 - Verner's \"Most Efficient\" 5/6  TanYam7 - Tanaka-Yamashita 7  DP8 - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method  TsitPap8 - Tsitouras-Papakostas 8/7  Vern9 - Verner's \"Most Efficient\" 9/8  Feagin10 - Feagin's Order 10/8 Method  Feagin12 - Feagin's Order 12/10 Method   Feagin14 - Feagin's Order 14/12 Method   General Explicit (Adaptive) Runge-Kutta Methods     These solvers are defined by tableaus. For a list of pre-defined tableaus, see  the ODE Solver options .   Stiff Solvers. Requires  NLsolve.jl . See  Conditional Dependencies .     Implicit Euler   Trapezoidal   Rosenbrock32   Wrappers for ODEInterface.jl. See  Conditional Dependencies .     dorpi5 - Hairer's DP5(4)   dop853 - Hairer's DP8(5,3)  odex - Extrapolation algorithm based on explicit midpoint rule  radau5 - Implicit Runge-Kutta order 5  radau - Implicit Runge-Kutta variable order 5-13   seulex - Extrapolation based on linear implicit Euler   Wrappers for ODE.jl. See  Conditional Dependencies .     ode23 - Bogacki-Shampine's method   ode45 - Dormand-Prince  4/5  ode78 - Runge-Kutta-Fehlberg  7/8  ode23s - Rosenbrock method 2/3  ode1 - Forward Euler  midpoint - Midpoint method  ode2_heun - Huen's method  ode4 - RK4   ode45_fe - Runge-Kutta-Fehlberg 4/5   Wrappers for Sundials.jl. See  Conditional Dependences .     cvode_BDF - The Lawrence Livermore CVODE BDF solver.   cvode_Adams - The Lawrence Livermore CVODE BDF solver Adams-Moulton solver.       SODEs   Euler-Maruyama  Milstein  Rossler-SRK     Finite Element Solvers (Stochastic) PDEs    Semilinear Poisson Equation    See implicit solvers   Semilinear Heat Equation (Reaction-Diffusion)     Forward Euler [Maruyama]   Backward Euler [Maruyama]  Semi-implicit Crank-Nicholson [Maruyama]   Semi-implicit Backward Euler [Maruyama]   Linear Heat Equation     Forward Euler [Maruyama]   Backward Euler [Maruyama]  Crank-Nicholson [Maruyama]       Implicit Solvers   Direct  Factorizations (LU, Cholesky, QR, SVD)  Conjugate-Gradient (CG)  GMRES", 
            "title": "Implemented Solvers"
        }, 
        {
            "location": "/#roadmap", 
            "text": "ODE Solvers   Stabilized stiff - ROCK2 and ROCK4   SODE Solvers    Adaptive-SRK    Finite difference solvers    Semi-linear Heat Equation (Reaction-Diffusion Equation)   Semi-linear Poisson Equation  Wave Equation  Transport Equation   Stochastic PDE Solvers    Implicit Integration Factor (IIF) Maruyama   Implicit Integration Factor (IIF) Milstein   DDE Solvers    Wrap RETARD and RADAR5   Implement standard Runge-Kutta DDE solvers   Algebraic differential equations    Implement standard solvers and add to ODEProblem type    Linear Solvers    Finite Difference Geometric Multigrids   Algebraic Multigrids via pyAMG   Performance    Improve FEM performance   Implement threaded versions  Test ParallelAccelerator.jl on solvers  Add Xeon Phi / GPU variants   Misc    Davie-Gaines convergence analysis   Add benchmarking tools  Improve MonteCarloSimulation", 
            "title": "Roadmap"
        }, 
        {
            "location": "/#ijulia-notebook-tutorials", 
            "text": "If you have  IJulia  installed, you can access extra tutorials in the supplied IJulia notebooks via:  using IJulia\ncd(Pkg.dir( DifferentialEquations )* /examples )\nnotebook()  Otherwise, these notebooks can be viewed  via the Github repository  (note that Github renders them slightly incorrectly, so it will look better in IJulia!).", 
            "title": "IJulia Notebook Tutorials"
        }, 
        {
            "location": "/#tutorials", 
            "text": "The following tutorials will introduce you to the functionality of DifferentialEquations.jl More examples can be found by  checking out the IJulia notebooks in the examples folder .   Ordinary Differential Equation (ODE) Example  Stochastic Differential Equation (SDE) Example  Poisson Equation Finite Element Method Example  Heat Equation Finite Element Method Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#solver-options", 
            "text": "These pages describe the options available in the solvers.   Ordinary Differential Equation Solvers  Recommended Methods  Full List of Methods  List of Supplied Tableaus  Analysis of Methods    Stochastic Differential Equation Solvers  Finite Element Method Poisson Equation Solvers  Finite Element Method Heat Equation Solvers    Finite Difference Method Stokes Equation Solvers  Stokes Equation", 
            "title": "Solver Options"
        }, 
        {
            "location": "/#manual", 
            "text": "Plot Functions  Standard Plots  Extra Plot Functions    Defining a FEM Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Internal Finite Element Tools  Mesh Tools  Solver Tools  Error Tools    Finite Element Method Poisson Equation Solvers  Meshes  Mesh Specification  Mesh Type  Mesh Generation Functions  Example Meshes  Plot Functions    Juno Progress Bar Integration  Conditional Dependencies  The Conditional Dependency Notification  What Methods Require Conditional Dependencies?  Installation Instructions    The Solution Type  Solution Types  Related Functions    Finite Difference Method Stokes Equation Solvers  Stokes Equation    Ordinary Differential Equation (ODE) Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation    Defining a Stokes Problem  Problem Type  Example Problems    Contributor's Guide  Developing New Solver Algorithms  Adding Conditional Dependencies  Developing A New Problem  Other Help    Defining a SDE Problem  Problem Type  Example Problems    Overview of DifferentialEquations.jl Usage  Extras for Developers and Researchers  Heat Equation Finite Element Method Example  Stochastic Differential Equation (SDE) Example  Finite Element Method Heat Equation Solvers    Solver Helpers  ODE Solver Extras  SDE Solver Extras  Stationary Stokes    Stochastic Differential Equation Solvers  Poisson Equation Finite Element Method Example  Defining an ODE Problem  Problem Type  Example Problems    Notes on Algorithms  Explicit Runge-Kutta ODE Algorithms    Convergence Simulations  The ConvergenceSimulation Type  Plot Functions  Related Functions    Ordinary Differential Equation Solvers  Recommended Methods  Full List of Methods  List of Supplied Tableaus  Analysis of Methods    Extra Functions  DifferentialEquations.jl Documentation  Using the Package  Supported Equations  Implemented Solvers  Roadmap  IJulia Notebook Tutorials  Tutorials  Solver Options  Manual  Internal Documentation  Index", 
            "title": "Manual"
        }, 
        {
            "location": "/#internal-documentation", 
            "text": "Plot Functions  Standard Plots  Extra Plot Functions    Defining a FEM Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Internal Finite Element Tools  Mesh Tools  Solver Tools  Error Tools    Finite Element Method Poisson Equation Solvers  Meshes  Mesh Specification  Mesh Type  Mesh Generation Functions  Example Meshes  Plot Functions    Juno Progress Bar Integration  Conditional Dependencies  The Conditional Dependency Notification  What Methods Require Conditional Dependencies?  Installation Instructions    The Solution Type  Solution Types  Related Functions    Finite Difference Method Stokes Equation Solvers  Stokes Equation    Ordinary Differential Equation (ODE) Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation    Defining a Stokes Problem  Problem Type  Example Problems    Contributor's Guide  Developing New Solver Algorithms  Adding Conditional Dependencies  Developing A New Problem  Other Help    Defining a SDE Problem  Problem Type  Example Problems    Overview of DifferentialEquations.jl Usage  Extras for Developers and Researchers  Heat Equation Finite Element Method Example  Stochastic Differential Equation (SDE) Example  Finite Element Method Heat Equation Solvers    Solver Helpers  ODE Solver Extras  SDE Solver Extras  Stationary Stokes    Stochastic Differential Equation Solvers  Poisson Equation Finite Element Method Example  Defining an ODE Problem  Problem Type  Example Problems    Notes on Algorithms  Explicit Runge-Kutta ODE Algorithms    Convergence Simulations  The ConvergenceSimulation Type  Plot Functions  Related Functions    Ordinary Differential Equation Solvers  Recommended Methods  Full List of Methods  List of Supplied Tableaus  Analysis of Methods    Extra Functions  DifferentialEquations.jl Documentation  Using the Package  Supported Equations  Implemented Solvers  Roadmap  IJulia Notebook Tutorials  Tutorials  Solver Options  Manual  Internal Documentation  Index", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "DifferentialEquations.ODE_DEFAULT_TABLEAU  DifferentialEquations.ConvergenceSimulation  DifferentialEquations.DEProblem  DifferentialEquations.DESolution  DifferentialEquations.ExplicitRKTableau  DifferentialEquations.FEMSolution  DifferentialEquations.FEMmesh  DifferentialEquations.HeatProblem  DifferentialEquations.Mesh  DifferentialEquations.ODEProblem  DifferentialEquations.ODESolution  DifferentialEquations.PoissonProblem  DifferentialEquations.RosslerSRA  DifferentialEquations.RosslerSRI  DifferentialEquations.SDEProblem  DifferentialEquations.SDESolution  DifferentialEquations.SimpleMesh  DifferentialEquations.StokesProblem  DifferentialEquations.StokesSolution  DifferentialEquations.Tableau  Base.length  Base.length  DifferentialEquations.CFL\u03bc  DifferentialEquations.CFL\u03bd  DifferentialEquations.FEMSolutionTS  DifferentialEquations.GSu!  DifferentialEquations.GSv!  DifferentialEquations.GS\u03b4q!  DifferentialEquations.additiveSDEExample  DifferentialEquations.animate  DifferentialEquations.appxTrue!  DifferentialEquations.assemblematrix  DifferentialEquations.calc_rp!  DifferentialEquations.calc\ud835\udcaaestimates  DifferentialEquations.checkSRAOrder  DifferentialEquations.checkSRIOrder  DifferentialEquations.constructCashKarp  DifferentialEquations.constructDormandPrince  DifferentialEquations.constructDormandPrince8  DifferentialEquations.constructHuen  DifferentialEquations.constructRKF8  DifferentialEquations.constructRalston  DifferentialEquations.constructSRA1  DifferentialEquations.constructSRIW1  DifferentialEquations.cubicSDEExample  DifferentialEquations.dirichletzeroStokesExample  DifferentialEquations.fem_squaremesh  DifferentialEquations.findboundary  DifferentialEquations.getH1error  DifferentialEquations.getL2error  DifferentialEquations.getNoise  DifferentialEquations.heatProblemExample_birthdeath  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem  DifferentialEquations.heatProblemExample_birthdeathsystem  DifferentialEquations.heatProblemExample_diffuse  DifferentialEquations.heatProblemExample_diffusionconstants  DifferentialEquations.heatProblemExample_gierermeinhardt  DifferentialEquations.heatProblemExample_grayscott  DifferentialEquations.heatProblemExample_moving  DifferentialEquations.heatProblemExample_pure  DifferentialEquations.heatProblemExample_stochasticbirthdeath  DifferentialEquations.homogeneousStokesExample  DifferentialEquations.linearODEExample  DifferentialEquations.linearSDEExample  DifferentialEquations.meshExample_Lshapemesh  DifferentialEquations.meshExample_Lshapeunstructure  DifferentialEquations.meshExample_bunny  DifferentialEquations.meshExample_flowpastcylindermesh  DifferentialEquations.meshExample_lakemesh  DifferentialEquations.meshExample_oilpump  DifferentialEquations.meshExample_wavymesh  DifferentialEquations.meshExample_wavyperturbmesh  DifferentialEquations.monteCarloSim  DifferentialEquations.multiDimAdditiveSDEExample  DifferentialEquations.notime_squaremesh  DifferentialEquations.numparameters  DifferentialEquations.parabolic_squaremesh  DifferentialEquations.poissonProblemExample_birthdeath  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem  DifferentialEquations.poissonProblemExample_birthdeathsystem  DifferentialEquations.poissonProblemExample_noisyWave  DifferentialEquations.poissonProblemExample_wave  DifferentialEquations.quadfbasis  DifferentialEquations.quadpts  DifferentialEquations.quadpts1  DifferentialEquations.setboundary  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.stokes_prolongation  DifferentialEquations.stokes_restriction  DifferentialEquations.test_convergence  DifferentialEquations.twoDimlinearODEExample  DifferentialEquations.twoDimlinearSDEExample  DifferentialEquations.update_p!  DifferentialEquations.update_u!  DifferentialEquations.update_v!  DifferentialEquations.uzawa_p!  DifferentialEquations.waveSDEExample  DifferentialEquations.\u2207basis  DifferentialEquations.\u2207u", 
            "title": "Index"
        }, 
        {
            "location": "/tutorials/ode_example/", 
            "text": "Ordinary Differential Equation (ODE) Example\n\n\nThis tutorial will introduce you to the functionality for solving ODEs. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the equation\n\n\n$$\n\\frac{du}{dt} = f(u,t)\n$$\n\n\nwhere $f(u,t)=\u03b1u$. We know via Calculus that the solution to this equation is $u(t)=u\u2080\\exp(\u03b1t)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nusing DifferentialEquations\n\u03b1=1\nu\u2080=1/2\nf(u,t) = u\nprob = ODEProblem(f,u\u2080)\n\n\n\n\nThen we setup some parameters:\n\n\n\u0394t = 1/2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nWe then send these items to the solver.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:Euler)\n\n\n\n\nTo see what's in the solution object, we can print it:\n\n\nprint(sol)\n#DifferentialEquations.ODESolution with 17 timesteps. No analytical solution is known.\n#u: 1.3189642486832998\n#t: [0.0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1.0]\n#timeseries: [0.5,0.53125,0.564453,0.599731,0.637215,0.677041,0.719356,0.764315,0.812085,0.86284,0.916768,0.974066,1.03494,1.09963,1.16836,1.24138,1.31896]\n\n\n\n\nWe can access the 5th value of the solution with\n\n\nsol[5]\n#.637\n\n\n\n\nor get the time of the 8th timestep by\n\n\nsol.t[8]\n#.438\n\n\n\n\nPlotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:\n\n\nplot(sol)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n\n\n\n\nThe plot function can be formatted using \nthe attributes available in Plots.jl\n. For more of an introduction to plotting solutions, \nsee the IJulia notebook\n.\n\n\n\n\nOther Algorithms\n\n\nWe can choose a better algorithm by specifying:\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK,adaptive=false)\nplot(sol)\nPlots.gui()\n\n\n\n\n\n\nThe \n\"ExplicitRK\"\n algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's \node45\n. Please see the solver documentation for more algorithms.\n\n\nWe can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument (note: this is true by default):\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:ExplicitRK,adaptive=true)\nplot(sol)\nPlots.gui()\n\n\n\n\n\n\n\n\nSystems of Equations\n\n\nWe can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:\n\n\nu\u2080=rand(4,2).*ones(4,2)/2\n\u03b1=ones(4,2)\nf(u,t) = \u03b1.*u\nprob = ODEProblem(f,u\u2080)\n\n\n\n\nHere our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK)\nplot(sol)\nPlots.gui()", 
            "title": "Ordinary Differential Equation Example"
        }, 
        {
            "location": "/tutorials/ode_example/#ordinary-differential-equation-ode-example", 
            "text": "This tutorial will introduce you to the functionality for solving ODEs. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the equation  $$\n\\frac{du}{dt} = f(u,t)\n$$  where $f(u,t)=\u03b1u$. We know via Calculus that the solution to this equation is $u(t)=u\u2080\\exp(\u03b1t)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:  using DifferentialEquations\n\u03b1=1\nu\u2080=1/2\nf(u,t) = u\nprob = ODEProblem(f,u\u2080)  Then we setup some parameters:  \u0394t = 1/2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  We then send these items to the solver.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:Euler)  To see what's in the solution object, we can print it:  print(sol)\n#DifferentialEquations.ODESolution with 17 timesteps. No analytical solution is known.\n#u: 1.3189642486832998\n#t: [0.0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1.0]\n#timeseries: [0.5,0.53125,0.564453,0.599731,0.637215,0.677041,0.719356,0.764315,0.812085,0.86284,0.916768,0.974066,1.03494,1.09963,1.16836,1.24138,1.31896]  We can access the 5th value of the solution with  sol[5]\n#.637  or get the time of the 8th timestep by  sol.t[8]\n#.438  Plotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:  plot(sol)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()  The plot function can be formatted using  the attributes available in Plots.jl . For more of an introduction to plotting solutions,  see the IJulia notebook .", 
            "title": "Ordinary Differential Equation (ODE) Example"
        }, 
        {
            "location": "/tutorials/ode_example/#other-algorithms", 
            "text": "We can choose a better algorithm by specifying:  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK,adaptive=false)\nplot(sol)\nPlots.gui()   The  \"ExplicitRK\"  algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's  ode45 . Please see the solver documentation for more algorithms.  We can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument (note: this is true by default):  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:ExplicitRK,adaptive=true)\nplot(sol)\nPlots.gui()", 
            "title": "Other Algorithms"
        }, 
        {
            "location": "/tutorials/ode_example/#systems-of-equations", 
            "text": "We can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:  u\u2080=rand(4,2).*ones(4,2)/2\n\u03b1=ones(4,2)\nf(u,t) = \u03b1.*u\nprob = ODEProblem(f,u\u2080)  Here our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK)\nplot(sol)\nPlots.gui()", 
            "title": "Systems of Equations"
        }, 
        {
            "location": "/tutorials/sde_example/", 
            "text": "Stochastic Differential Equation (SDE) Example\n\n\nThis tutorial will introduce you to the functionality for solving SDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the equation\n\n\n$$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nwhere $f(u,t)=\u03b1u$ and $\u03c3(u,t)=\u03b2u$. We know via Stochastic Calculus that the solution to this equation is $u(t,W)=u\u2080\\exp((\u03b1-\\frac{\u03b2^2}{2})t+\u03b2W)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nusing DifferentialEquations\n\u03b1=1\n\u03b2=1\nu\u2080=1/2\nf(u,t) = \u03b1*u\n\u03c3(u,t) = \u03b2*u\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nFor reference, let's also give the \nSDEProblem\n the analytical solution. Note that each of the problem types allow for this, but it's always optional. This can be a good way to judge how accurate the algorithms are, or is used to test convergence of the algorithms for methods developers. Thus we define the problem object with:\n\n\nanalytic(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\nprob = SDEProblem(f,\u03c3,u\u2080,analytic=analytic)\n\n\n\n\nand then we pass this information to the solver and plot:\n\n\n#We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:EM)\nplot(sol,plot_analytic=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n\n\n\n\n\n\nWe can choose a higher-order solver for a more accurate result:\n\n\n#We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:SRIW1Optimized)\nplot(sol,plot_analytic=true)\nPlots.gui()", 
            "title": "Stochastic Differential Equation Example"
        }, 
        {
            "location": "/tutorials/sde_example/#stochastic-differential-equation-sde-example", 
            "text": "This tutorial will introduce you to the functionality for solving SDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the equation  $$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  where $f(u,t)=\u03b1u$ and $\u03c3(u,t)=\u03b2u$. We know via Stochastic Calculus that the solution to this equation is $u(t,W)=u\u2080\\exp((\u03b1-\\frac{\u03b2^2}{2})t+\u03b2W)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:  using DifferentialEquations\n\u03b1=1\n\u03b2=1\nu\u2080=1/2\nf(u,t) = \u03b1*u\n\u03c3(u,t) = \u03b2*u\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  For reference, let's also give the  SDEProblem  the analytical solution. Note that each of the problem types allow for this, but it's always optional. This can be a good way to judge how accurate the algorithms are, or is used to test convergence of the algorithms for methods developers. Thus we define the problem object with:  analytic(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\nprob = SDEProblem(f,\u03c3,u\u2080,analytic=analytic)  and then we pass this information to the solver and plot:  #We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:EM)\nplot(sol,plot_analytic=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()   We can choose a higher-order solver for a more accurate result:  #We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:SRIW1Optimized)\nplot(sol,plot_analytic=true)\nPlots.gui()", 
            "title": "Stochastic Differential Equation (SDE) Example"
        }, 
        {
            "location": "/tutorials/fempoisson_example/", 
            "text": "Poisson Equation Finite Element Method Example\n\n\nThis tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the Poisson Equation $\u0394u=f$. For our example, we will take the linear equation where $f(x,y) = \\sin(2\u03c0x)\\cos(2\u03c0y)$. For this equation we know that solution is $u(x,y,t)= \\sin(2\u03c0x)\\cos(2\u03c0y)/(8\u03c0^2)$ with gradient $Du(x,y) = [\\cos(2\u03c0x)\\cos(2\u03c0y)/(4\u03c0) -\\sin(2\u03c0x)\\sin(2\u03c0y)/(4\u03c0)]$. Thus, we define a PoissonProblem as follows:\n\n\nf(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\ngD(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\nprob = PoissonProblem(f,gD)\n\n\n\n\nHere we chose the dirichlet boundary condition \ngD\n to give the theoretical solution.  Other example problems can be found in \nsrc/examples/exampleProblems.jl\n. To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:\n\n\n\u0394x = 1//2^(5)\nfem_mesh = notime_squaremesh([0 1 0 1],\u0394x,:dirichlet)\n\n\n\n\nNote that by specifying :dirichlet our boundary conditions is set on all boundaries to dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as \niFEM\n. Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use\n\n\nsol = solve(fem_mesh,pdeProb)\n\n\n\n\nsolve takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This returns a FEMSolution object which holds data about the solution, such as the solution values (u). To plot the solution, we use the command\n\n\nplot(sol::FEMSolution)\nPlots.gui()\n\n\n\n\nHere is the plot shown against the analytical solution to show the accuracy:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/fempoisson_example/#poisson-equation-finite-element-method-example", 
            "text": "This tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the Poisson Equation $\u0394u=f$. For our example, we will take the linear equation where $f(x,y) = \\sin(2\u03c0x)\\cos(2\u03c0y)$. For this equation we know that solution is $u(x,y,t)= \\sin(2\u03c0x)\\cos(2\u03c0y)/(8\u03c0^2)$ with gradient $Du(x,y) = [\\cos(2\u03c0x)\\cos(2\u03c0y)/(4\u03c0) -\\sin(2\u03c0x)\\sin(2\u03c0y)/(4\u03c0)]$. Thus, we define a PoissonProblem as follows:  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\ngD(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\nprob = PoissonProblem(f,gD)  Here we chose the dirichlet boundary condition  gD  to give the theoretical solution.  Other example problems can be found in  src/examples/exampleProblems.jl . To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:  \u0394x = 1//2^(5)\nfem_mesh = notime_squaremesh([0 1 0 1],\u0394x,:dirichlet)  Note that by specifying :dirichlet our boundary conditions is set on all boundaries to dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as  iFEM . Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use  sol = solve(fem_mesh,pdeProb)  solve takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This returns a FEMSolution object which holds data about the solution, such as the solution values (u). To plot the solution, we use the command  plot(sol::FEMSolution)\nPlots.gui()  Here is the plot shown against the analytical solution to show the accuracy:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femheat_example/", 
            "text": "Heat Equation Finite Element Method Example\n\n\nThis tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the heat equation $u_t=\u0394u+f$. To do this, we define a HeatProblem which contains the function $f$ and the boundary conditions. We specify one as follows:\n\n\nf(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\nprob = HeatProblem(u\u2080,f)\n\n\n\n\nHere the equation we chose was nonlinear since $f$ depends on the variable $u$. Thus we specify f=f(u,x,t). If $f$ did not depend on u, then we would specify f=f(x,t). We do need to specify $gD$ (the dirichlet boundary condition) and $gN$ (the neumann boundary condition) since both are zero. $u0$ specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.\n\n\nWe then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command\n\n\nT = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\n\n\n\nWe then call the solver\n\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler)\n\n\n\n\nHere we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femheat_example/#heat-equation-finite-element-method-example", 
            "text": "This tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the heat equation $u_t=\u0394u+f$. To do this, we define a HeatProblem which contains the function $f$ and the boundary conditions. We specify one as follows:  f(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\nprob = HeatProblem(u\u2080,f)  Here the equation we chose was nonlinear since $f$ depends on the variable $u$. Thus we specify f=f(u,x,t). If $f$ did not depend on u, then we would specify f=f(x,t). We do need to specify $gD$ (the dirichlet boundary condition) and $gN$ (the neumann boundary condition) since both are zero. $u0$ specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.  We then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command  T = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)  We then call the solver  sol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler)  Here we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femstochastic_example/", 
            "text": "Stochastic Finite Element Examples\n\n\nThis tutorial will introduce you to the functionality for solving SPDEs. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nFor most PDE problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments $dW$, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noisetype which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.\n\n\nThe following examples show how to change the tutorial problems into stochastic problems.\n\n\n\n\nFinite Element Stochastic Poisson Equation\n\n\nWe can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  $-\u0394u=f+gdW$, with additive space-time white noise by specifying the problem as:\n\n\nf(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n\u03c3(x) = 5 #Additive noise\nprob = PoissonProblem(f,\u03c3=\u03c3)\nsolve(prob)\n\n\n\n\nThis gives the following plot (with adding the deterministic solution from the previous example):\n\n\n\n\n\n\nFinite Element Stochastic Heat Equation\n\n\nThis will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function \nf(u)=.5-u\n, noise function \ng(u)=100u^2\n and initial condition \nu0=0\n. We would expect this system to rise towards the deterministic steady state \nu=2\n (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:\n\n\nf(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\n\u03c3(u,x,t) = 1u.^2\nprob = HeatProblem(u\u2080,f,\u03c3=\u03c3)\n\n\n\n\nWe use the following code create an animation of the solution:\n\n\nT = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler,save_timeseries=true,solver=:LU)\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#stochastic-finite-element-examples", 
            "text": "This tutorial will introduce you to the functionality for solving SPDEs. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  For most PDE problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments $dW$, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noisetype which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.  The following examples show how to change the tutorial problems into stochastic problems.", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#finite-element-stochastic-poisson-equation", 
            "text": "We can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  $-\u0394u=f+gdW$, with additive space-time white noise by specifying the problem as:  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n\u03c3(x) = 5 #Additive noise\nprob = PoissonProblem(f,\u03c3=\u03c3)\nsolve(prob)  This gives the following plot (with adding the deterministic solution from the previous example):", 
            "title": "Finite Element Stochastic Poisson Equation"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#finite-element-stochastic-heat-equation", 
            "text": "This will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function  f(u)=.5-u , noise function  g(u)=100u^2  and initial condition  u0=0 . We would expect this system to rise towards the deterministic steady state  u=2  (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:  f(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\n\u03c3(u,x,t) = 1u.^2\nprob = HeatProblem(u\u2080,f,\u03c3=\u03c3)  We use the following code create an animation of the solution:  T = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler,save_timeseries=true,solver=:LU)\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Finite Element Stochastic Heat Equation"
        }, 
        {
            "location": "/solvers/ode_solve/", 
            "text": "Ordinary Differential Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::ODEProblem,tspan)\n\n\nSolves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\ntableau\n: The tableau for an \n:ExplicitRK\n algorithm. Defaults to a Dormand-Prince 4/5 method.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is true.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is .9.\n\n\ntimechoicealg\n - Chooses the method which is used for making the adaptive timestep choices. Default is \n:Lund\n for Lund stabilization (PI stepsize control). The other option is \n:Simple\n for the standard simple error-based rejection\n\n\n\u03b2\n - The Lund stabilization \u03b2 parameter. Defaults are algorithm-dependent.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 10.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\nautodiff\n - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use \nNLsolve\n. Default is true.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\nalg\n: The solver algorithm. Defult is \n:DP5\n. Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify \nSSBETA=0.03\n as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as \nMAXSS\n (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax \n\u0394tmax\n or \nMAXSS\n. The possibilities for the solvers are:\n\n\n\n\nFor a full list of algorithms, please see the solver documentation.\n\n\nsource\n\n\n\n\nRecommended Methods\n\n\nCurrently, a total of 120 algorithm choices are available. This guide is to help you choose the right one.\n\n\n\n\nNon-Stiff Problems\n\n\nFor non-stiff problems, the native DifferentialEquations.jl algorithms are vastly more efficient than the other choices (ODEInterface and ODE.jl). For most non-stiff problems, we recommend \n:DP5\n (this is the default algorithm). When more robust error control is required, \n:BS5\n is a good choice. For fast solving at lower tolerances, we recommend \n:BS3\n. For tolerances which are at about the truncation error of Float64 (1e-16), we recommend \n:DP8\n as a robust choice and \n:Vern9\n as an efficient choice.\n\n\nFor high accuracy non-stiff solving, we recommend the \n:Feagin12\n or \n:Feagin14\n methods. These are more robust than Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods.\n\n\n\n\nStiff Problems\n\n\nFor mildly stiff problems, \n:Rosenbrock32\n is a good choice. As a native DifferentialEquations.jl solver, all Julia-defined numbers will work. This method uses ForwardDiff to automatically guess the Jacobian. For faster solving when the Jacobian is known, use \nradau\n. For highly stiff problems where Julia-defined numbers need to be used (SIUnits, Arbs), \n:Trapezoid\n is the current best choice. However, for the most efficient non-stiff solvers, use \n:radau\n or \n:cvode_BDF\n.\n\n\n\n\nFull List of Methods\n\n\nChoose one of these methods with the \nalg\n keyword in \nsolve\n.\n\n\n\n\n\n\nDifferentialEquations.jl\n\n\n\n\n:Euler\n- The canonical forward Euler method.\n\n\n:Midpoint\n - The second order midpoint method.\n\n\n:RK4\n - The canonical Runge-Kutta Order 4 method.\n\n\n:BS3\n - Bogacki-Shampine 2/3 method.\n\n\n:DP5\n - Dormand-Prince's 4/5 Runge-Kutta method.\n\n\nTsit5\n - Tsitouras 4/5 Runge-Kutta method.\n\n\nBS5\n - Bogacki-Shampine 4/5 Runge-Kutta method.\n\n\nVern6\n - Verner's \"Most Efficient\" 5/6 Runge-Kutta method.\n\n\nTanYam7\n - Tanaka-Yamashita 7 Runge-Kutta method.\n\n\nDP8\n - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method.\n\n\nTsitPap8\n - Tsitouras-Papakostas 8/7 Runge-Kutta method.\n\n\nVern9\n - Verner's \"Most Efficient\" 9/8 Runge-Kutta method.\n\n\n:Feagin10\n - Feagin's 10th-order Runge-Kutta method.\n\n\n:Feagin12\n - Feagin's 12th-order Runge-Kutta method.\n\n\n:Feagin14\n - Feagin's 14th-order Runge-Kutta method.\n\n\n:ExplicitRK\n - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument \ntab=tableau\n. The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.\n\n\n:ImplicitEuler\n - A 1st order implicit solver. Unconditionally stable.\n\n\n:Trapezoid\n - A second order unconditionally stable implicit solver. Good for highly stiff.\n\n\n:Rosenbrock32\n - A fast solver which is good for mildy stiff equations.\n\n\n\n\nDifferentialEquations.jl Vectorized Implementations (Not as efficient, allocate, but may be useful for specific purposes)\n\n\n\n\nExplicitRKVectorized\n - A general Runge-Kutta solver which takes in a tableau. Can be adaptive.\n\n\nBS3Vectorized\n - Bogacki-Shampine 2/3 Runge-Kutta method.\n\n\nTsit5Vectorized\n - Tsitouras 4/5 Runge-Kutta method.\n\n\nBS5Vectorized\n - Bogacki-Shampine 4/5 Runge-Kutta method.\n\n\nVern6Vectorized\n - Verner's \"Most Efficient\" 5/6 Runge-Kutta method.\n\n\nTanYam7Vectorized\n - Tanaka-Yamashita 7 Runge-Kutta method.\n\n\nDP8Vectorized\n - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method.\n\n\nTsitPap8Vectorized\n - Tsitouras-Papakostas 8/7 Runge-Kutta method.\n\n\nVern9Vectorized\n - Verner's \"Most Efficient\" 9/8 Runge-Kutta method.\n\n\n:Feagin10Vectorized\n - Feagin's 10th-order Runge-Kutta method.\n\n\n:Feagin12Vectorized\n - Feagin's 12th-order Runge-Kutta method.\n\n\n:Feagin14Vectorized\n - Feagin's 14th-order Runge-Kutta method.\n\n\nODEInterface.jl\n\n\n\n\n\n\n\n\n:dopri5\n - Hairer's classic implementation of the Dormand-Prince 4/5 method.\n\n\n\n\n:dop853\n - Explicit Runge-Kutta 8(5,3) by Dormand-Prince\n\n\n:odex\n - GBS extrapolation-algorithm based on the midpoint rule\n\n\n:seulex\n - extrapolation-algorithm based on the linear implicit Euler method\n\n\n:radau\n - implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13\n\n\n:radau5\n - implicit Runge-Kutta method (Radau IIA) of order 5\n\n\n\n\nODE.jl\n\n\n\n\n\n\n:ode23\n - Bogakai-Shampine's 2/3 method\n\n\n\n\n:ode45\n - Dormand-Prince's 4/5 method\n\n\n:ode78\n - Runge-Kutta-Fehlberg 7/8 method\n\n\n:ode23s\n - Rosenbrock's 2/3 method\n\n\n:ode1\n - Forward Euler\n\n\n:ode2_midpoint\n - Midpoint Method\n\n\n:ode2_heun\n - Heun's Method\n\n\n:ode4\n - RK4\n\n\n:ode45_fe\n - Runge-Kutta-Fehlberg 4/5 method\n\n\nSundials.jl\n\n\n:cvode_BDF\n - CVode Backward Differentiation Formula (BDF) solver.\n\n\n:cvode_Adams\n - CVode Adams-Moulton solver\n\n\n\n\n\n\n\n\n\n\nList of Supplied Tableaus\n\n\nA large variety of tableaus have been supplied by default. For the most useful and common algorithms, a hand-optimized version is supplied and is recommended for general uses (i.e. use \n:DP5\n instead of \n:ExplicitRK\n with \ntableau=constructDormandPrince()\n). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exist). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the \npremade tableau source code\n. Tableau docstrings should have appropriate citations (if not, file an issue).\n\n\n[Note: I hope to in the near future implement plot recipes which will plot the stability regions for a given tableau, and calculate the coefficient of the highest order truncation error term.]\n\n\n\n\nconstructHuen()\n Huen's order 2 method.\n\n\nconstructRalston()\n - Ralston's order 2 method.\n\n\nconstructBogakiShampine3()\n - Bogakai-Shampine's 2/3 method.\n\n\nconstructRKF4()\n - Runge-Kutta-Fehlberg 3/4.\n\n\nconstructRKF5()\n - Runge-Kutta-Fehlberg 4/5.\n\n\nconstructRungeFirst5()\n - Runge's first 5th order method.\n\n\nconstructCassity5()\n - Cassity's 5th order method.\n\n\nconstructLawson5()\n - Lawson's 5th order method.\n\n\nconstructLutherKonen5\n - Luther-Konen's first 5th order method.\n\n\nconstructLutherKonen52()\n - Luther-Konen's second 5th order method.\n\n\nconstructLutherKonen53()\n - Luther-Konen's third 5th order method.\n\n\nconstructPapakostasPapaGeorgiou5()\n - Papakostas and PapaGeorgiou more stable order 5 method.\n\n\nconstructPapakostasPapaGeorgiou52()\n - Papakostas and PapaGeorgiou more efficient order 5 method.\n\n\nconstructTsitouras5()\n - Tsitouras's order 5 method.\n\n\nconstructBogakiShampine5()\n - Bogaki and Shampine's Order 5 method.\n\n\nconstructSharpSmart5()\n - Sharp and Smart's Order 5 method.\n\n\nconstructCashKarp()\n - Cash-Karp method 4/5.\n\n\nconstructDormandPrince()\n - Dormand-Prince 4/5.\n\n\nconstructButcher6()\n - Butcher's first order 6 method.\n\n\nconstructButcher62()\n - Butcher's second order 6 method.\n\n\nconstructButcher63()\n - Butcher's third order 6 method.\n\n\nconstructDormandPrince6()\n - Dormand-Prince's 5/6 method.\n\n\nconstructSharpVerner6()\n Sharp-Verner's 5/6 method.\n\n\nconstructVerner916()\n - Verner's more efficient order 6 method (1991).\n\n\nconstructVerner9162()\n - Verner's second more efficient order 6 method (1991).\n\n\nconstructVernerRobust6()\n - Verner's \"most robust\" order 6 method.\n\n\nconstructVernerEfficient6()\n - Verner's \"most efficient\" order 6 method.\n\n\nconstructPapakostas6()\n - Papakostas's order 6 method.\n\n\nconstructLawson6()\n - Lawson's order 6 method.\n\n\nconstructTsitourasPapakostas6()\n - Tsitouras and Papakostas's order 6 method.\n\n\nconstructDormandLockyerMcCorriganPrince6()\n - the Dormand-Lockyer-McCorrigan-Prince order 6 method.\n\n\nconstructTanakaKasugaYamashitaYazaki6A()\n - Tanaka-Kasuga-Yamashita-Yazaki order 6 method A.\n\n\nconstructTanakaKasugaYamashitaYazaki6B()\n - Tanaka-Kasuga-Yamashita-Yazaki order 6 method B.\n\n\nconstructTanakaKasugaYamashitaYazaki6C()\n - Tanaka-Kasuga-Yamashita-Yazaki order 6 method C.\n\n\nconstructTanakaKasugaYamashitaYazaki6D()\n - Tanaka-Kasuga-Yamashita-Yazaki order 6 method D.\n\n\nconstructMikkawyEisa()\n - Mikkawy and Eisa's order 6 method.\n\n\nconstructChummund6()\n - Chummund's first order 6 method.\n\n\nconstructChummund62()\n - Chummund's second order 6 method.\n\n\nconstructHuta6()\n - Huta's first order 6 method.\n\n\nconstructHuta62()\n - Huta's second order 6 method.\n\n\nconstructVerner6()\n - An old order 6 method attributed to Verner.\n\n\nconstructDverk()\n - The classic DVERK algorithm attributed to Verner.\n\n\nconstructClassicVerner6()\n - A classic Verner order 6 algorithm (1978).\n\n\nconstructButcher7()\n - Butcher's order 7 algorithm.\n\n\nconstructClassicVerner7()\n- A classic Verner order 7 algorithm (1978).\n\n\nconstructVernerRobust7()\n - Verner's \"most robust\" order 7 algorithm.\n\n\nconstructTanakaYamashitaStable7()\n - Tanaka-Yamashita more stable order 7 algorithm.\n\n\nconstructTanakaYamashitaEfficient7()\n - Tanaka-Yamashita more efficient order 7 algorithm.\n\n\nconstructSharpSmart7()\n - Sharp-Smart's order 7 algorithm.\n\n\nconstructSharpVerner7()\n - Sharp-Verner's order 7 algorithm.\n\n\nconstructVernerEfficient7()\n - Verner's \"most efficient\" order 7 algorithm.\n\n\nconstructClassicVerner8()\n - A classic Verner order 8 algorithm (1978).\n\n\nconstructCooperVerner8()\n - Cooper-Verner's first order 8 algorithm.\n\n\nconstructCooperVerner82()\n - Cooper-Verner's second order 8 algorithm.\n\n\nconstructTsitourasPapakostas8()\n - Tsitouras-Papakostas order 8 algorithm.\n\n\nconstructdverk78()\n - The classic order 8 DVERK algorithm.\n\n\nconstructEnrightVerner8()\n - Enright-Verner order 8 algorithm.\n\n\nconstructCurtis8()\n - Curtis' order 8 algorithm.\n\n\nconstructRKF8()\n - Runge-Kutta-Fehlberg Order 7/8 method.\n\n\nconstructDormandPrice8()\n - Dormand-Prince Order 7/8 method.\n\n\nconstructDormandPrince8_64bit()\n - Dormand-Prince Order 7/8 method. Coefficients are rational approximations good for 64 bits.\n\n\nconstructVernerRobust9()\n - Verner's \"most robust\" order 9 method.\n\n\nconstructVernerEfficient9()\n - Verner's \"most efficient\" order 9 method.\n\n\nconstructSharp9()\n - Sharp's order 9 method.\n\n\nconstructTsitouras9()\n - Tsitouras's first order 9 method.\n\n\nconstructTsitouras92()\n - Tsitouras's second order 9 method.\n\n\nconstructCurtis10()\n - Curtis' order 10 method.\n\n\nconstructOno10()\n - Ono's order 10 method.\n\n\nconstructFeagin10Tableau()\n - Feagin's order 10 method.\n\n\nconstructCurtis10()\n - Curtis' order 10 method.\n\n\nconstructBaker10()\n - Baker's order 10 method.\n\n\nconstructHairer10()\n Hairer's order 10 method.\n\n\nconstructFeagin12Tableau()\n - Feagin's order 12 method.\n\n\nconstructOno12()\n - Ono's order 12 method.\n\n\nconstructFeagin14Tableau()\n Feagin's order 14 method.\n\n\n\n\n\n\nAnalysis of Methods\n\n\nFor a walkthrough of the various method pros/cons, see \nnotes on algorithms", 
            "title": "Ordinary Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/ode_solve/#ordinary-differential-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::ODEProblem,tspan)  Solves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  tableau : The tableau for an  :ExplicitRK  algorithm. Defaults to a Dormand-Prince 4/5 method.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is true.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is .9.  timechoicealg  - Chooses the method which is used for making the adaptive timestep choices. Default is  :Lund  for Lund stabilization (PI stepsize control). The other option is  :Simple  for the standard simple error-based rejection  \u03b2  - The Lund stabilization \u03b2 parameter. Defaults are algorithm-dependent.  qmax  - Defines the maximum value possible for the adaptive q. Default is 10.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  autodiff  - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use  NLsolve . Default is true.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.  alg : The solver algorithm. Defult is  :DP5 . Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify  SSBETA=0.03  as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as  MAXSS  (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax  \u0394tmax  or  MAXSS . The possibilities for the solvers are:   For a full list of algorithms, please see the solver documentation.  source", 
            "title": "Ordinary Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/ode_solve/#recommended-methods", 
            "text": "Currently, a total of 120 algorithm choices are available. This guide is to help you choose the right one.", 
            "title": "Recommended Methods"
        }, 
        {
            "location": "/solvers/ode_solve/#non-stiff-problems", 
            "text": "For non-stiff problems, the native DifferentialEquations.jl algorithms are vastly more efficient than the other choices (ODEInterface and ODE.jl). For most non-stiff problems, we recommend  :DP5  (this is the default algorithm). When more robust error control is required,  :BS5  is a good choice. For fast solving at lower tolerances, we recommend  :BS3 . For tolerances which are at about the truncation error of Float64 (1e-16), we recommend  :DP8  as a robust choice and  :Vern9  as an efficient choice.  For high accuracy non-stiff solving, we recommend the  :Feagin12  or  :Feagin14  methods. These are more robust than Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods.", 
            "title": "Non-Stiff Problems"
        }, 
        {
            "location": "/solvers/ode_solve/#stiff-problems", 
            "text": "For mildly stiff problems,  :Rosenbrock32  is a good choice. As a native DifferentialEquations.jl solver, all Julia-defined numbers will work. This method uses ForwardDiff to automatically guess the Jacobian. For faster solving when the Jacobian is known, use  radau . For highly stiff problems where Julia-defined numbers need to be used (SIUnits, Arbs),  :Trapezoid  is the current best choice. However, for the most efficient non-stiff solvers, use  :radau  or  :cvode_BDF .", 
            "title": "Stiff Problems"
        }, 
        {
            "location": "/solvers/ode_solve/#full-list-of-methods", 
            "text": "Choose one of these methods with the  alg  keyword in  solve .    DifferentialEquations.jl   :Euler - The canonical forward Euler method.  :Midpoint  - The second order midpoint method.  :RK4  - The canonical Runge-Kutta Order 4 method.  :BS3  - Bogacki-Shampine 2/3 method.  :DP5  - Dormand-Prince's 4/5 Runge-Kutta method.  Tsit5  - Tsitouras 4/5 Runge-Kutta method.  BS5  - Bogacki-Shampine 4/5 Runge-Kutta method.  Vern6  - Verner's \"Most Efficient\" 5/6 Runge-Kutta method.  TanYam7  - Tanaka-Yamashita 7 Runge-Kutta method.  DP8  - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method.  TsitPap8  - Tsitouras-Papakostas 8/7 Runge-Kutta method.  Vern9  - Verner's \"Most Efficient\" 9/8 Runge-Kutta method.  :Feagin10  - Feagin's 10th-order Runge-Kutta method.  :Feagin12  - Feagin's 12th-order Runge-Kutta method.  :Feagin14  - Feagin's 14th-order Runge-Kutta method.  :ExplicitRK  - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument  tab=tableau . The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.  :ImplicitEuler  - A 1st order implicit solver. Unconditionally stable.  :Trapezoid  - A second order unconditionally stable implicit solver. Good for highly stiff.  :Rosenbrock32  - A fast solver which is good for mildy stiff equations.   DifferentialEquations.jl Vectorized Implementations (Not as efficient, allocate, but may be useful for specific purposes)   ExplicitRKVectorized  - A general Runge-Kutta solver which takes in a tableau. Can be adaptive.  BS3Vectorized  - Bogacki-Shampine 2/3 Runge-Kutta method.  Tsit5Vectorized  - Tsitouras 4/5 Runge-Kutta method.  BS5Vectorized  - Bogacki-Shampine 4/5 Runge-Kutta method.  Vern6Vectorized  - Verner's \"Most Efficient\" 5/6 Runge-Kutta method.  TanYam7Vectorized  - Tanaka-Yamashita 7 Runge-Kutta method.  DP8Vectorized  - Hairer's 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method.  TsitPap8Vectorized  - Tsitouras-Papakostas 8/7 Runge-Kutta method.  Vern9Vectorized  - Verner's \"Most Efficient\" 9/8 Runge-Kutta method.  :Feagin10Vectorized  - Feagin's 10th-order Runge-Kutta method.  :Feagin12Vectorized  - Feagin's 12th-order Runge-Kutta method.  :Feagin14Vectorized  - Feagin's 14th-order Runge-Kutta method.  ODEInterface.jl     :dopri5  - Hairer's classic implementation of the Dormand-Prince 4/5 method.   :dop853  - Explicit Runge-Kutta 8(5,3) by Dormand-Prince  :odex  - GBS extrapolation-algorithm based on the midpoint rule  :seulex  - extrapolation-algorithm based on the linear implicit Euler method  :radau  - implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13  :radau5  - implicit Runge-Kutta method (Radau IIA) of order 5   ODE.jl    :ode23  - Bogakai-Shampine's 2/3 method   :ode45  - Dormand-Prince's 4/5 method  :ode78  - Runge-Kutta-Fehlberg 7/8 method  :ode23s  - Rosenbrock's 2/3 method  :ode1  - Forward Euler  :ode2_midpoint  - Midpoint Method  :ode2_heun  - Heun's Method  :ode4  - RK4  :ode45_fe  - Runge-Kutta-Fehlberg 4/5 method  Sundials.jl  :cvode_BDF  - CVode Backward Differentiation Formula (BDF) solver.  :cvode_Adams  - CVode Adams-Moulton solver", 
            "title": "Full List of Methods"
        }, 
        {
            "location": "/solvers/ode_solve/#list-of-supplied-tableaus", 
            "text": "A large variety of tableaus have been supplied by default. For the most useful and common algorithms, a hand-optimized version is supplied and is recommended for general uses (i.e. use  :DP5  instead of  :ExplicitRK  with  tableau=constructDormandPrince() ). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exist). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the  premade tableau source code . Tableau docstrings should have appropriate citations (if not, file an issue).  [Note: I hope to in the near future implement plot recipes which will plot the stability regions for a given tableau, and calculate the coefficient of the highest order truncation error term.]   constructHuen()  Huen's order 2 method.  constructRalston()  - Ralston's order 2 method.  constructBogakiShampine3()  - Bogakai-Shampine's 2/3 method.  constructRKF4()  - Runge-Kutta-Fehlberg 3/4.  constructRKF5()  - Runge-Kutta-Fehlberg 4/5.  constructRungeFirst5()  - Runge's first 5th order method.  constructCassity5()  - Cassity's 5th order method.  constructLawson5()  - Lawson's 5th order method.  constructLutherKonen5  - Luther-Konen's first 5th order method.  constructLutherKonen52()  - Luther-Konen's second 5th order method.  constructLutherKonen53()  - Luther-Konen's third 5th order method.  constructPapakostasPapaGeorgiou5()  - Papakostas and PapaGeorgiou more stable order 5 method.  constructPapakostasPapaGeorgiou52()  - Papakostas and PapaGeorgiou more efficient order 5 method.  constructTsitouras5()  - Tsitouras's order 5 method.  constructBogakiShampine5()  - Bogaki and Shampine's Order 5 method.  constructSharpSmart5()  - Sharp and Smart's Order 5 method.  constructCashKarp()  - Cash-Karp method 4/5.  constructDormandPrince()  - Dormand-Prince 4/5.  constructButcher6()  - Butcher's first order 6 method.  constructButcher62()  - Butcher's second order 6 method.  constructButcher63()  - Butcher's third order 6 method.  constructDormandPrince6()  - Dormand-Prince's 5/6 method.  constructSharpVerner6()  Sharp-Verner's 5/6 method.  constructVerner916()  - Verner's more efficient order 6 method (1991).  constructVerner9162()  - Verner's second more efficient order 6 method (1991).  constructVernerRobust6()  - Verner's \"most robust\" order 6 method.  constructVernerEfficient6()  - Verner's \"most efficient\" order 6 method.  constructPapakostas6()  - Papakostas's order 6 method.  constructLawson6()  - Lawson's order 6 method.  constructTsitourasPapakostas6()  - Tsitouras and Papakostas's order 6 method.  constructDormandLockyerMcCorriganPrince6()  - the Dormand-Lockyer-McCorrigan-Prince order 6 method.  constructTanakaKasugaYamashitaYazaki6A()  - Tanaka-Kasuga-Yamashita-Yazaki order 6 method A.  constructTanakaKasugaYamashitaYazaki6B()  - Tanaka-Kasuga-Yamashita-Yazaki order 6 method B.  constructTanakaKasugaYamashitaYazaki6C()  - Tanaka-Kasuga-Yamashita-Yazaki order 6 method C.  constructTanakaKasugaYamashitaYazaki6D()  - Tanaka-Kasuga-Yamashita-Yazaki order 6 method D.  constructMikkawyEisa()  - Mikkawy and Eisa's order 6 method.  constructChummund6()  - Chummund's first order 6 method.  constructChummund62()  - Chummund's second order 6 method.  constructHuta6()  - Huta's first order 6 method.  constructHuta62()  - Huta's second order 6 method.  constructVerner6()  - An old order 6 method attributed to Verner.  constructDverk()  - The classic DVERK algorithm attributed to Verner.  constructClassicVerner6()  - A classic Verner order 6 algorithm (1978).  constructButcher7()  - Butcher's order 7 algorithm.  constructClassicVerner7() - A classic Verner order 7 algorithm (1978).  constructVernerRobust7()  - Verner's \"most robust\" order 7 algorithm.  constructTanakaYamashitaStable7()  - Tanaka-Yamashita more stable order 7 algorithm.  constructTanakaYamashitaEfficient7()  - Tanaka-Yamashita more efficient order 7 algorithm.  constructSharpSmart7()  - Sharp-Smart's order 7 algorithm.  constructSharpVerner7()  - Sharp-Verner's order 7 algorithm.  constructVernerEfficient7()  - Verner's \"most efficient\" order 7 algorithm.  constructClassicVerner8()  - A classic Verner order 8 algorithm (1978).  constructCooperVerner8()  - Cooper-Verner's first order 8 algorithm.  constructCooperVerner82()  - Cooper-Verner's second order 8 algorithm.  constructTsitourasPapakostas8()  - Tsitouras-Papakostas order 8 algorithm.  constructdverk78()  - The classic order 8 DVERK algorithm.  constructEnrightVerner8()  - Enright-Verner order 8 algorithm.  constructCurtis8()  - Curtis' order 8 algorithm.  constructRKF8()  - Runge-Kutta-Fehlberg Order 7/8 method.  constructDormandPrice8()  - Dormand-Prince Order 7/8 method.  constructDormandPrince8_64bit()  - Dormand-Prince Order 7/8 method. Coefficients are rational approximations good for 64 bits.  constructVernerRobust9()  - Verner's \"most robust\" order 9 method.  constructVernerEfficient9()  - Verner's \"most efficient\" order 9 method.  constructSharp9()  - Sharp's order 9 method.  constructTsitouras9()  - Tsitouras's first order 9 method.  constructTsitouras92()  - Tsitouras's second order 9 method.  constructCurtis10()  - Curtis' order 10 method.  constructOno10()  - Ono's order 10 method.  constructFeagin10Tableau()  - Feagin's order 10 method.  constructCurtis10()  - Curtis' order 10 method.  constructBaker10()  - Baker's order 10 method.  constructHairer10()  Hairer's order 10 method.  constructFeagin12Tableau()  - Feagin's order 12 method.  constructOno12()  - Ono's order 12 method.  constructFeagin14Tableau()  Feagin's order 14 method.", 
            "title": "List of Supplied Tableaus"
        }, 
        {
            "location": "/solvers/ode_solve/#analysis-of-methods", 
            "text": "For a walkthrough of the various method pros/cons, see  notes on algorithms", 
            "title": "Analysis of Methods"
        }, 
        {
            "location": "/solvers/sde_solve/", 
            "text": "Stochastic Differential Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::SDEProblem,tspan)\n\n\nSolves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is false.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 1.125.\n\n\n\u03b4\n - The weight-factor in the error estimate. Default is 1/6.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\ndiscard_length\n - Size at which to discard future information in adaptive. Default is 1e-15.\n\n\ntableau\n: The tableau for an \n:SRA\n or \n:SRI\n algorithm. Defaults to SRIW1 or SRA1.\n\n\nadaptivealg\n: The adaptive timestepping algorithm. Default is \n:RSwm3\n.\n\n\n\n\nalg\n: String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:\n\n\n\n\n:EM\n- The Euler-Maruyama method.\n\n\n:RKMil\n - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.\n\n\n:SRA\n - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.\n\n\n:SRI\n - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.\n\n\n:SRIW1Optimized\n - An optimized version of SRIW1. Strong Order 1.5.\n\n\n:SRA1Optimized\n - An optimized version of SRIA1. Strong Order 2.0.\n\n\n:SRAVectorized\n - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.\n\n\n:SRIVectorized\n - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Stochastic Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/sde_solve/#stochastic-differential-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::SDEProblem,tspan)  Solves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is false.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax  - Defines the maximum value possible for the adaptive q. Default is 1.125.  \u03b4  - The weight-factor in the error estimate. Default is 1/6.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.  discard_length  - Size at which to discard future information in adaptive. Default is 1e-15.  tableau : The tableau for an  :SRA  or  :SRI  algorithm. Defaults to SRIW1 or SRA1.  adaptivealg : The adaptive timestepping algorithm. Default is  :RSwm3 .   alg : String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:   :EM - The Euler-Maruyama method.  :RKMil  - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.  :SRA  - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.  :SRI  - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.  :SRIW1Optimized  - An optimized version of SRIW1. Strong Order 1.5.  :SRA1Optimized  - An optimized version of SRIA1. Strong Order 2.0.  :SRAVectorized  - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.  :SRIVectorized  - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.     source", 
            "title": "Stochastic Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/fempoisson_solve/", 
            "text": "Finite Element Method Poisson Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Poisson Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation $-\u0394u = f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves \nAx=b\n using \n\\\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Poisson Equation Finite Element Method Solvers"
        }, 
        {
            "location": "/solvers/fempoisson_solve/#finite-element-method-poisson-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  Finite Element Poisson Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation $-\u0394u = f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.  Keyword Arguments    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves  Ax=b  using  \\  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.     source", 
            "title": "Finite Element Method Poisson Equation Solvers"
        }, 
        {
            "location": "/solvers/femheat_solve/", 
            "text": "Finite Element Method Heat Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Heat Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation $u_t = \u0394u + f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nalg\n = Solution algorithm. Default is :Euler. The choices are:\n\n\n\n\n\n\nLinear\n\n\n\n\n:Euler\n (Explicit)\n\n\n:ImplicitEuler\n (Implicit)\n\n\n\n\n:CrankNicholson\n (Implicit)\n\n\n\n\nNonlinear\n\n\n\n\n\n\n\n\n:Euler\n (Explicit)\n\n\n\n\n:ImplicitEuler\n (Nonlinear Solve)\n\n\n:CrankNicholson\n (Nonlinear Solve)\n\n\n:SemiImplicitEuler\n (Implicit)\n\n\n:SemiImplicitCrankNicholson\n (Implicit)\n\n\n\n\n\n\n\n\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves using \n\\\n (no factorization). Not recommended.\n\n\n:Cholesky\n = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\n:LU\n = LU-Decomposition. A good mix between fast and stable.\n\n\n:QR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\n:SVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\nsave_timeseries\n = Makes the algorithm save the output at every \ntimeseries_steps\n timesteps. By default save_timeseries is false.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\nprogress_steps\n = The number of steps between updates of the progress bar. Defaults to 1000.\n\n\nprogressbar\n = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Heat Equation Finite Element Method Solvers"
        }, 
        {
            "location": "/solvers/femheat_solve/#finite-element-method-heat-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  Finite Element Heat Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation $u_t = \u0394u + f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.  Keyword Arguments    alg  = Solution algorithm. Default is :Euler. The choices are:    Linear   :Euler  (Explicit)  :ImplicitEuler  (Implicit)   :CrankNicholson  (Implicit)   Nonlinear     :Euler  (Explicit)   :ImplicitEuler  (Nonlinear Solve)  :CrankNicholson  (Nonlinear Solve)  :SemiImplicitEuler  (Implicit)  :SemiImplicitCrankNicholson  (Implicit)       Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves using  \\  (no factorization). Not recommended.  :Cholesky  = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.  :LU  = LU-Decomposition. A good mix between fast and stable.  :QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  :SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  save_timeseries  = Makes the algorithm save the output at every  timeseries_steps  timesteps. By default save_timeseries is false.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.  progress_steps  = The number of steps between updates of the progress bar. Defaults to 1000.  progressbar  = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.     source", 
            "title": "Finite Element Method Heat Equation Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/", 
            "text": "Finite Difference Method Stokes Equation Solvers\n\n\n\n\nStokes Equation\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::StokesProblem,mesh::FDMMesh)\n\n\nSolves the given stationary Stokes problem on the given finite difference mesh.\n\n\nKeyword Arguments\n\n\n\n\nconverrors\n: Whether to calculate all of the errors along the convergence. Default is true.\n\n\nmaxiters\n: Maximum number of iterations before haulting. Default is 100.\n\n\nalg\n: The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".\n\n\nlevel\n: The number of levels in the Multigrid. Default is 2.\n\n\nsmoothSteps\n: The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.\n\n\ncoarseSteps\n: The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.\n\n\ngsiters\n: The number of Gauss-Seidel iterations to do at each step. Default is 20.\n\n\n\n\nsource", 
            "title": "Stationary Stokes Equation Finite Difference Method Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/#finite-difference-method-stokes-equation-solvers", 
            "text": "", 
            "title": "Finite Difference Method Stokes Equation Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/#stokes-equation", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::StokesProblem,mesh::FDMMesh)  Solves the given stationary Stokes problem on the given finite difference mesh.  Keyword Arguments   converrors : Whether to calculate all of the errors along the convergence. Default is true.  maxiters : Maximum number of iterations before haulting. Default is 100.  alg : The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".  level : The number of levels in the Multigrid. Default is 2.  smoothSteps : The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.  coarseSteps : The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.  gsiters : The number of Gauss-Seidel iterations to do at each step. Default is 20.   source", 
            "title": "Stokes Equation"
        }, 
        {
            "location": "/man/overview/", 
            "text": "Overview of DifferentialEquations.jl Usage\n\n\nThe general workflow for using the package is as follows:\n\n\n\n\nDefine a problem\n\n\nGenerate a mesh\n\n\nUse a solver on the problem and mesh\n\n\nAnalyze the output\n\n\n\n\nProblems are specified via a type interface. For example, for the Poisson equation $\u0394u = f$, one defines a type which holds \nf\n and the boundary condition functions. Many examples problems can be found in \nsrc/premades/premade_problems.jl\n\n\nNext, for PDE problems, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. $[0,1]^2 \\times [0,T]$, then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.\n\n\nOne then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.\n\n\nWith the solution object, you do the analysis as you please! For some result \nsol\n, the field \nsol.u\n returns the final solution, and if you give a true solution, \nsol.u_analytic\n is the true solution at the final time. If you specified to the solver \nsave_timeseries=true\n, then \nsol.timeseries\n and \nsol.ts\n will be outputted which hold the solution/time at every \ntimeseries_steps\n (default set to 100, meaning it saves an output every 100 steps).\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nsave_timeseries\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.\n\n\n\n\nExtras for Developers and Researchers\n\n\nDifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. The problem types allow one to optionally specify the true solution. When this is given to the solver, the solution object returns with many error calculations. An array of solutions can be made into a \nConvergenceSimulation\n (or the test_convergence functions can be used) which then generates all of the convergence test results and allows for plotting (great for developing new methods!).\n\n\nNear Future:\n\n\nThe \nBenchmarkSimulations\n allows one to compare between methods and easily plot the results. Also, recipes are provided for Runge-Kutta tableaus to plot stability regions and calculate the coefficient of the highest order truncation error term.", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#overview-of-differentialequationsjl-usage", 
            "text": "The general workflow for using the package is as follows:   Define a problem  Generate a mesh  Use a solver on the problem and mesh  Analyze the output   Problems are specified via a type interface. For example, for the Poisson equation $\u0394u = f$, one defines a type which holds  f  and the boundary condition functions. Many examples problems can be found in  src/premades/premade_problems.jl  Next, for PDE problems, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. $[0,1]^2 \\times [0,T]$, then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.  One then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.  With the solution object, you do the analysis as you please! For some result  sol , the field  sol.u  returns the final solution, and if you give a true solution,  sol.u_analytic  is the true solution at the final time. If you specified to the solver  save_timeseries=true , then  sol.timeseries  and  sol.ts  will be outputted which hold the solution/time at every  timeseries_steps  (default set to 100, meaning it saves an output every 100 steps).  Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  save_timeseries  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#extras-for-developers-and-researchers", 
            "text": "DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. The problem types allow one to optionally specify the true solution. When this is given to the solver, the solution object returns with many error calculations. An array of solutions can be made into a  ConvergenceSimulation  (or the test_convergence functions can be used) which then generates all of the convergence test results and allows for plotting (great for developing new methods!).  Near Future:  The  BenchmarkSimulations  allows one to compare between methods and easily plot the results. Also, recipes are provided for Runge-Kutta tableaus to plot stability regions and calculate the coefficient of the highest order truncation error term.", 
            "title": "Extras for Developers and Researchers"
        }, 
        {
            "location": "/man/ODEProblem/", 
            "text": "Defining an ODE Problem\n\n\nTo define an ODE Problem, you simply need to give the function $f$ and the initial condition $u\u2080$ which define an ODE\n\n\n$$\ndu/dt = f(u,t)\n$$\n\n\nf\n should be specified as \nf(u,t)\n and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.ODEProblem\n \n \nType\n.\n\n\nODEProblem\n\n\nWraps the data which defines an SDE problem\n\n\n$$\ndu/dt = f(u,t)\n$$\n\n\nwith initial condition $u\u2080$.\n\n\nConstructors\n\n\nODEProblem(f,u\u2080;analytic=nothing)\n : Defines the SDE with the specified functions and defines the solution if analytic is given.\n\n\nFields\n\n\n\n\nf\n: The drift function in the ODE.\n\n\nu\u2080\n: The initial condition.\n\n\nanalytic\n: A function which describes the solution.\n\n\nknownanalytic\n: True if the solution is given.\n\n\nnumvars\n: The number of variables in the system\n\n\n\n\nsource\n\n\n\n\nExample Problems\n\n\nExamples problems can be found in \nsrc/premades/premade_problems.jl\n\n\n#\n\n\nDifferentialEquations.twoDimlinearODEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear ODEs (as a 4x2 matrix) with solution $u(t)=exp(\u03b1.*t)$ and random initial conditions\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.linearODEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t)=u\u2080\nexp(\u03b1\nt)$\n\n\nsource", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/ODEProblem/#defining-an-ode-problem", 
            "text": "To define an ODE Problem, you simply need to give the function $f$ and the initial condition $u\u2080$ which define an ODE  $$\ndu/dt = f(u,t)\n$$  f  should be specified as  f(u,t)  and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well.", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/ODEProblem/#problem-type", 
            "text": "#  DifferentialEquations.ODEProblem     Type .  ODEProblem  Wraps the data which defines an SDE problem  $$\ndu/dt = f(u,t)\n$$  with initial condition $u\u2080$.  Constructors  ODEProblem(f,u\u2080;analytic=nothing)  : Defines the SDE with the specified functions and defines the solution if analytic is given.  Fields   f : The drift function in the ODE.  u\u2080 : The initial condition.  analytic : A function which describes the solution.  knownanalytic : True if the solution is given.  numvars : The number of variables in the system   source", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/ODEProblem/#example-problems", 
            "text": "Examples problems can be found in  src/premades/premade_problems.jl  #  DifferentialEquations.twoDimlinearODEExample     Function .  Example problem of 8 linear ODEs (as a 4x2 matrix) with solution $u(t)=exp(\u03b1.*t)$ and random initial conditions  source  #  DifferentialEquations.linearODEExample     Function .  Example problem with solution $u(t)=u\u2080 exp(\u03b1 t)$  source", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/SDEProblem/", 
            "text": "Defining a SDE Problem\n\n\nTo define an SDE Problem, you simply need to give the forcing function $f$, the noise function \n\u03c3\n, and the initial condition $u\u2080$ which define an SDE\n\n\n$$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nf\n and \n\u03c3\n should be specified as \nf(u,t)\n and  \n\u03c3(u,t)\n respectively, and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well. A vector of \n\u03c3\ns can also be defined to determine an SDE of higher Ito dimension.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.SDEProblem\n \n \nType\n.\n\n\nSDEProblem\n\n\nWraps the data which defines an SDE problem\n\n\n$$\nu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nwith initial condition $u\u2080$.\n\n\nConstructors\n\n\nSDEProblem(f,\u03c3,u\u2080;analytic=nothing)\n : Defines the SDE with the specified functions and defines the solution if analytic is given.\n\n\nFields\n\n\n\n\nf\n: The drift function in the SDE.\n\n\n\u03c3\n: The noise function in the SDE.\n\n\nu\u2080\n: The initial condition.\n\n\nanalytic\n: A function which describes the solution.\n\n\nknownanalytic\n: True if the solution is given.\n\n\nnumvars\n: The number of variables in the system\n\n\nsizeu\n: The size of the initial condition (and thus \nu\n)\n\n\n\n\nsource\n\n\n\n\nExample Problems\n\n\nExamples problems can be found in \nsrc/premades/premade_problems.jl\n\n\n#\n\n\nDifferentialEquations.twoDimlinearSDEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear SDEs (as a 4x2 matrix) with solution $u(t,W)=u\u2080\nexp((\u03b1-(\u03b2^2)/2)\nt+\u03b2*W)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.cubicSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=((1+u\u2080)\nexp(W)+u\u2080-1)./((1+u\u2080)\nexp(W)+1-u\u2080)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.linearSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=u\u2080\nexp((\u03b1-(\u03b2^2)/2)\nt+\u03b2*W)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n \n \nFunction\n.\n\n\nMultiple Ito dimension extension of additiveSDEExample\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.waveSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=atan(0.1*W + tan(u\u2080))$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.additiveSDEExample\n \n \nFunction\n.\n\n\nExample additive noise problem with solution $u\u2080./sqrt(1+t) + \u03b2\n(t+\u03b1\nW)./sqrt(1+t)$\n\n\nsource", 
            "title": "Defining an SDE Problem"
        }, 
        {
            "location": "/man/SDEProblem/#defining-a-sde-problem", 
            "text": "To define an SDE Problem, you simply need to give the forcing function $f$, the noise function  \u03c3 , and the initial condition $u\u2080$ which define an SDE  $$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  f  and  \u03c3  should be specified as  f(u,t)  and   \u03c3(u,t)  respectively, and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well. A vector of  \u03c3 s can also be defined to determine an SDE of higher Ito dimension.", 
            "title": "Defining a SDE Problem"
        }, 
        {
            "location": "/man/SDEProblem/#problem-type", 
            "text": "#  DifferentialEquations.SDEProblem     Type .  SDEProblem  Wraps the data which defines an SDE problem  $$\nu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  with initial condition $u\u2080$.  Constructors  SDEProblem(f,\u03c3,u\u2080;analytic=nothing)  : Defines the SDE with the specified functions and defines the solution if analytic is given.  Fields   f : The drift function in the SDE.  \u03c3 : The noise function in the SDE.  u\u2080 : The initial condition.  analytic : A function which describes the solution.  knownanalytic : True if the solution is given.  numvars : The number of variables in the system  sizeu : The size of the initial condition (and thus  u )   source", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/SDEProblem/#example-problems", 
            "text": "Examples problems can be found in  src/premades/premade_problems.jl  #  DifferentialEquations.twoDimlinearSDEExample     Function .  Example problem of 8 linear SDEs (as a 4x2 matrix) with solution $u(t,W)=u\u2080 exp((\u03b1-(\u03b2^2)/2) t+\u03b2*W)$  source  #  DifferentialEquations.cubicSDEExample     Function .  Example problem with solution $u(t,W)=((1+u\u2080) exp(W)+u\u2080-1)./((1+u\u2080) exp(W)+1-u\u2080)$  source  #  DifferentialEquations.linearSDEExample     Function .  Example problem with solution $u(t,W)=u\u2080 exp((\u03b1-(\u03b2^2)/2) t+\u03b2*W)$  source  #  DifferentialEquations.multiDimAdditiveSDEExample     Function .  Multiple Ito dimension extension of additiveSDEExample  source  #  DifferentialEquations.waveSDEExample     Function .  Example problem with solution $u(t,W)=atan(0.1*W + tan(u\u2080))$  source  #  DifferentialEquations.additiveSDEExample     Function .  Example additive noise problem with solution $u\u2080./sqrt(1+t) + \u03b2 (t+\u03b1 W)./sqrt(1+t)$  source", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/FEMProblem/", 
            "text": "Defining a FEM Problem\n\n\nBelow are the definitions of the types which specify problems. Some general notes are:\n\n\n\n\n(x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as $f(x,y,t)$. However, in this code we use \nx\n as a vector. Thus you can think of $x$=\nx[:,1]\n and $y$=\nx[:,2]\n. Thus input equations are of the form \nf(x,t)\n no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use \nf(x)\n. An example is the equation $u(x,y)= sin(2\u03c0x)cos(2\u03c0y)/(8\u03c0^2)$ would be specified as \nsol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n.\n\n\nLinearity: If the equation has linear term, they are specified with functions \nf(x,t)\n. If it is nonlinear, it is specified with functions \nf(u,x,t)\n. The boundary conditions are always \n(x,t)\n\n\nStochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic $\u03c3(u,x,t)dW_t$ term to the equation (or with $\u03c3(x,t)dW_t$ if linear, must match \nf\n). $dW_t$ corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.\n\n\n\n\n\n\nPoisson Equation Problem\n\n\n#\n\n\nDifferentialEquations.PoissonProblem\n \n \nType\n.\n\n\nPoissonProblem\n\n\nWraps the data that define a 2D linear Poisson equation problem:\n\n\n$$\n-\u0394u = f\n$$\n\n\nwith bounday conditions \ngD\n on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of one variable \n(x)\n or two \n(u,x)\n (with \nx=[:,1]\n and \ny=[:,2]\n).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n$$\n-\u0394u = f + \u03c3dW\n$$\n\n\nConstructors\n\n\nPoissonProblem(f,analytic,Du)\n: Defines the dirichlet problem with analytical solution \nanalytic\n, solution gradient \nDu = [u_x,u_y]\n, and forcing function \nf\n\n\nPoissonProblem(u\u2080,f)\n: Defines the problem with initial value \nu\u2080\n (as a function) and f. If your initial data is a vector, wrap it as \nu\u2080(x) = vector\n.\n\n\nNote: If all functions are of \n(x)\n, then the program assumes it's linear. Write your functions using the math to program syntrax translation: $x$ \n= x[:,1]\n and $y$ \n= x[:,2]\n. Use \nf=f(u,x)\n and \n\u03c3=\u03c3(u,x)\n (if specified) for nonlinear problems (with the boundary conditions still (x)). Systems of equations can be specified with \nu_i = u[:,i]\n as the ith variable. See the example problems for more help.\n\n\nKeyword Arguments\n\n\n\n\ngD\n = dirichlet boundary function\n\n\ngN\n = neumann boundary function\n\n\n\u03c3\n = The function which multiplies the noise $dW$. By default \n\u03c3=0\n.\n\n\nnoisetype\n = A string which specifies the type of noise to be generated. By default \nnoisetype=:White\n for Gaussian Spacetime White Noise.\n\n\nnumvars\n = The number of variables in the Poisson system. Automatically calculated in many cases.\n\n\nD\n = Vector of diffusion coefficients. Defaults is \nD=ones(1,numvars)\n.\n\n\n\n\nsource\n\n\n\n\nHeat Equation Problem\n\n\n#\n\n\nDifferentialEquations.HeatProblem\n \n \nType\n.\n\n\nHeatProblem\n\n\nWraps the data that define a 2D heat equation problem:\n\n\n$$\nu_t = \u0394u + f\n$$\n\n\nwith bounday conditions \ngD\n on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables \n(x,t)\n or three \n(u,x,t)\n (with \nx=[:,1]\n and \ny=[:,2]\n).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n$$\nu_t = \u0394u + f + \u03c3dW_t\n$$\n\n\nConstructors\n\n\n\n\nHeatProblem(analytic,Du,f)\n: Defines the dirichlet problem with solution \nanalytic\n, solution gradient \nDu = [u_x,u_y]\n, and the forcing function \nf\n.\n\n\nHeatProblem(u\u2080,f)\n: Defines the problem with initial value \nu\u2080\n (as a function) and \nf\n. If your initial data is a vector, wrap it as \nu\u2080(x) = vector\n.\n\n\n\n\nNote: If all functions are of \n(x,t)\n, then the program assumes it's linear. Write your functions using the math to program syntrax translation: $x$ \n= x[:,1]\n and $y$ \n= x[:,2]\n. Use \nf=f(u,x,t)\n and \n\u03c3=\u03c3(u,x,t)\n (if specified) for nonlinear problems (with the boundary conditions still (x,t)). Systems of equations can be specified with \nu_i = u[:,i]\n as the ith variable. See the example problems for more help.\n\n\nKeyword Arguments\n\n\n\n\ngD\n = dirichlet boundary function\n\n\ngN\n = neumann boundary function\n\n\n\u03c3\n = The function which multiplies the noise dW. By default \n\u03c3=0\n.\n\n\nnoisetype\n = A string which specifies the type of noise to be generated. By default \nnoisetype=:White\n for Gaussian Spacetime White Noise.\n\n\nnumvars\n = Number of variables in the system. Automatically calculated from u\u2080 in most cases.\n\n\nD\n = Array which defines the diffusion coefficients. Default is \nD=ones(1,numvars)\n.\n\n\n\n\nsource\n\n\n\n\nExample Problems\n\n\nExamples problems can be found in \nsrc/premades/premade_problems.jl\n\n\n\n\nPoisson Equation\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_wave\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n \n \nFunction\n.\n\n\nExample problem with deterministic solution: $u(x,y)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem for nonlinear Poisson equation. Uses $f(u)=1-u/2$.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$\n\n\nsource\n\n\n\n\nHeat Equation\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffuse\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_pure\n \n \nFunction\n.\n\n\nExample problem which starts with 1 at (0.5,0.5) and solves with $f=gD=0$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_moving\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y,t)=0.1\n(1-exp(-100\n(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with $f(u)=1-u/2$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with $f(u)=1-u/2$ with noise $\u03c3(u)=10u^2$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n \n \nFunction\n.\n\n\nExample problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n \n \nFunction\n.\n\n\nExample problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_grayscott\n \n \nFunction\n.\n\n\nExample problem which solves the Gray-Scott equations with quasi-random initial conditions\n\n\nsource\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.DEProblem\n \n \nType\n.\n\n\nPdeProblem: Defines differential equation problems via its internal functions\n\n\nsource", 
            "title": "Defining a Finite Element Problem"
        }, 
        {
            "location": "/man/FEMProblem/#defining-a-fem-problem", 
            "text": "Below are the definitions of the types which specify problems. Some general notes are:   (x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as $f(x,y,t)$. However, in this code we use  x  as a vector. Thus you can think of $x$= x[:,1]  and $y$= x[:,2] . Thus input equations are of the form  f(x,t)  no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use  f(x) . An example is the equation $u(x,y)= sin(2\u03c0x)cos(2\u03c0y)/(8\u03c0^2)$ would be specified as  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0) .  Linearity: If the equation has linear term, they are specified with functions  f(x,t) . If it is nonlinear, it is specified with functions  f(u,x,t) . The boundary conditions are always  (x,t)  Stochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic $\u03c3(u,x,t)dW_t$ term to the equation (or with $\u03c3(x,t)dW_t$ if linear, must match  f ). $dW_t$ corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.", 
            "title": "Defining a FEM Problem"
        }, 
        {
            "location": "/man/FEMProblem/#poisson-equation-problem", 
            "text": "#  DifferentialEquations.PoissonProblem     Type .  PoissonProblem  Wraps the data that define a 2D linear Poisson equation problem:  $$\n-\u0394u = f\n$$  with bounday conditions  gD  on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function  f  is a function of one variable  (x)  or two  (u,x)  (with  x=[:,1]  and  y=[:,2] ).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  $$\n-\u0394u = f + \u03c3dW\n$$", 
            "title": "Poisson Equation Problem"
        }, 
        {
            "location": "/man/FEMProblem/#constructors", 
            "text": "PoissonProblem(f,analytic,Du) : Defines the dirichlet problem with analytical solution  analytic , solution gradient  Du = [u_x,u_y] , and forcing function  f  PoissonProblem(u\u2080,f) : Defines the problem with initial value  u\u2080  (as a function) and f. If your initial data is a vector, wrap it as  u\u2080(x) = vector .  Note: If all functions are of  (x) , then the program assumes it's linear. Write your functions using the math to program syntrax translation: $x$  = x[:,1]  and $y$  = x[:,2] . Use  f=f(u,x)  and  \u03c3=\u03c3(u,x)  (if specified) for nonlinear problems (with the boundary conditions still (x)). Systems of equations can be specified with  u_i = u[:,i]  as the ith variable. See the example problems for more help.", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/FEMProblem/#keyword-arguments", 
            "text": "gD  = dirichlet boundary function  gN  = neumann boundary function  \u03c3  = The function which multiplies the noise $dW$. By default  \u03c3=0 .  noisetype  = A string which specifies the type of noise to be generated. By default  noisetype=:White  for Gaussian Spacetime White Noise.  numvars  = The number of variables in the Poisson system. Automatically calculated in many cases.  D  = Vector of diffusion coefficients. Defaults is  D=ones(1,numvars) .   source", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/FEMProblem/#heat-equation-problem", 
            "text": "#  DifferentialEquations.HeatProblem     Type .  HeatProblem  Wraps the data that define a 2D heat equation problem:  $$\nu_t = \u0394u + f\n$$  with bounday conditions  gD  on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables  (x,t)  or three  (u,x,t)  (with  x=[:,1]  and  y=[:,2] ).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  $$\nu_t = \u0394u + f + \u03c3dW_t\n$$", 
            "title": "Heat Equation Problem"
        }, 
        {
            "location": "/man/FEMProblem/#constructors_1", 
            "text": "HeatProblem(analytic,Du,f) : Defines the dirichlet problem with solution  analytic , solution gradient  Du = [u_x,u_y] , and the forcing function  f .  HeatProblem(u\u2080,f) : Defines the problem with initial value  u\u2080  (as a function) and  f . If your initial data is a vector, wrap it as  u\u2080(x) = vector .   Note: If all functions are of  (x,t) , then the program assumes it's linear. Write your functions using the math to program syntrax translation: $x$  = x[:,1]  and $y$  = x[:,2] . Use  f=f(u,x,t)  and  \u03c3=\u03c3(u,x,t)  (if specified) for nonlinear problems (with the boundary conditions still (x,t)). Systems of equations can be specified with  u_i = u[:,i]  as the ith variable. See the example problems for more help.", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/FEMProblem/#keyword-arguments_1", 
            "text": "gD  = dirichlet boundary function  gN  = neumann boundary function  \u03c3  = The function which multiplies the noise dW. By default  \u03c3=0 .  noisetype  = A string which specifies the type of noise to be generated. By default  noisetype=:White  for Gaussian Spacetime White Noise.  numvars  = Number of variables in the system. Automatically calculated from u\u2080 in most cases.  D  = Array which defines the diffusion coefficients. Default is  D=ones(1,numvars) .   source", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/FEMProblem/#example-problems", 
            "text": "Examples problems can be found in  src/premades/premade_problems.jl", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/FEMProblem/#poisson-equation", 
            "text": "#  DifferentialEquations.poissonProblemExample_wave     Function .  Example problem with solution: $u(x,y)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)$  source  #  DifferentialEquations.poissonProblemExample_noisyWave     Function .  Example problem with deterministic solution: $u(x,y)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)$  source  #  DifferentialEquations.poissonProblemExample_birthdeath     Function .  Example problem for nonlinear Poisson equation. Uses $f(u)=1-u/2$.  source  #  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$  source  #  DifferentialEquations.poissonProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$  source", 
            "title": "Poisson Equation"
        }, 
        {
            "location": "/man/FEMProblem/#heat-equation", 
            "text": "#  DifferentialEquations.heatProblemExample_diffuse     Function .  Example problem with solution: $u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)$  source  #  DifferentialEquations.heatProblemExample_pure     Function .  Example problem which starts with 1 at (0.5,0.5) and solves with $f=gD=0$  source  #  DifferentialEquations.heatProblemExample_moving     Function .  Example problem with solution: $u(x,y,t)=0.1 (1-exp(-100 (t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))$  source  #  DifferentialEquations.heatProblemExample_birthdeath     Function .  Example problem which starts with 0 and solves with $f(u)=1-u/2$  source  #  DifferentialEquations.heatProblemExample_stochasticbirthdeath     Function .  Example problem which starts with 0 and solves with $f(u)=1-u/2$ with noise $\u03c3(u)=10u^2$  source  #  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$  source  #  DifferentialEquations.heatProblemExample_gierermeinhardt     Function .  Example problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.  source  #  DifferentialEquations.heatProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$  source  #  DifferentialEquations.heatProblemExample_diffusionconstants     Function .  Example problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.  source  #  DifferentialEquations.heatProblemExample_grayscott     Function .  Example problem which solves the Gray-Scott equations with quasi-random initial conditions  source", 
            "title": "Heat Equation"
        }, 
        {
            "location": "/man/FEMProblem/#related-functions", 
            "text": "#  DifferentialEquations.DEProblem     Type .  PdeProblem: Defines differential equation problems via its internal functions  source", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/StokesProblem/", 
            "text": "Defining a Stokes Problem\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.StokesProblem\n \n \nType\n.\n\n\nStokesProblem\n\n\nDefines the solution to a stationary Stokes problem:\n\n\n$$\n\n\n$$\n\n\nConstructors\n\n\nStokesProblem(f\u2081,f\u2082,g,uanalytic,vanalytic,panalytic)\n\n\nStokesProblem(f\u2081,f\u2082,g,ugD,vgD)\n\n\nFields\n\n\n\n\nf\u2081::Function\n\n\nf\u2082::Function\n\n\ng::Function\n\n\nugD::Function\n\n\nvgD::Function\n\n\nuanalytic::Function\n\n\nvanalytic::Function\n\n\npanalytic::Function\n\n\ntrueknown::Bool\n\n\n\n\nsource\n\n\n\n\nExample Problems\n\n\nExamples problems can be found in \nsrc/premades/premade_problems.jl\n\n\n#\n\n\nDifferentialEquations.dirichletzeroStokesExample\n \n \nFunction\n.\n\n\nExample problme for solving the trivial stationary Stokes equation.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.homogeneousStokesExample\n \n \nFunction\n.\n\n\nExample problem for a homogeneous stationary Stokes equation.\n\n\nsource", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/StokesProblem/#defining-a-stokes-problem", 
            "text": "", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/StokesProblem/#problem-type", 
            "text": "#  DifferentialEquations.StokesProblem     Type .  StokesProblem  Defines the solution to a stationary Stokes problem:  $$  $$  Constructors  StokesProblem(f\u2081,f\u2082,g,uanalytic,vanalytic,panalytic)  StokesProblem(f\u2081,f\u2082,g,ugD,vgD)  Fields   f\u2081::Function  f\u2082::Function  g::Function  ugD::Function  vgD::Function  uanalytic::Function  vanalytic::Function  panalytic::Function  trueknown::Bool   source", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/StokesProblem/#example-problems", 
            "text": "Examples problems can be found in  src/premades/premade_problems.jl  #  DifferentialEquations.dirichletzeroStokesExample     Function .  Example problme for solving the trivial stationary Stokes equation.  source  #  DifferentialEquations.homogeneousStokesExample     Function .  Example problem for a homogeneous stationary Stokes equation.  source", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/mesh/", 
            "text": "Meshes\n\n\n\n\nMesh Specification\n\n\nFinite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:\n\n\n\n\nRow $i$ of node is an $(x,y)$ (or $(x,y,z)$) pair which specifies the coordinates\n\n\n\n\nof the $i$th node. * Row $j$ of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.\n\n\nFor example, to know the $(x,y)$ locations of the vertices of triangle $j$, we would see that $node[elem[j,i],:]$ are the $(x,y)$ locations of the $i$th vertex for $i=1,2,3$.\n\n\nFor more information, please see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\n\n\nMesh Type\n\n\n#\n\n\nDifferentialEquations.FEMmesh\n \n \nType\n.\n\n\nFEMmesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\nbdnode\n: Vector of indices for the boundary nodes.\n\n\nfreenode\n: Vector of indices for the free (non-dirichlet bound) nodes.\n\n\nbdedge\n: Indices of the edges in totaledge which are on the boundary.\n\n\nis_bdnode\n: Boolean which is true for nodes on the boundary.\n\n\nis_bdelem\n: Boolean which is true for elements on the boundary.\n\n\nbdflag\n: Flag which describes the type of boundary condition. 1=\n dirichlet,\n\n\n\n\n2=\nneumann, 3=\nrobin. * \ntotaledge\n: Vector of the edges. * \narea\n: Vector which is the area for each element. * \ndirichlet\n: Indices for the nodes on the boundary which have a dirichlet boundary condition. * \nneumann\n: Indices for the nodes on the boundary which have a neumann boundary condition. * \nrobin\n: Indices for the nodes on the boundary which have a robin boundary condition. * \nN::Int\n: The number of nodes. * \nNT\n::Int: The number of triangles (elements). * \n\u0394x\n: The spatial discretization size. If non-uniform, this is the average. * \n\u0394t\n: The time discretization size. If adaptive, this is the initial. * \nT\n::Number: The end time. * \nnumiters\n::Int: The number of iterations to go from 0 to T using \u0394t. * \n\u03bc\n: The CFL \u03bc stability parameter. * \n\u03bd\n: The CFL \u03bd stability parameter. * \nevolutionEq\n: True for a mesh which has non-trivial time components.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.SimpleMesh\n \n \nType\n.\n\n\nSimpleMesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.Mesh\n \n \nType\n.\n\n\nMesh: An abstract type which holds a (node,elem) pair and other information for a mesh\n\n\nsource\n\n\n\n\nMesh Generation Functions\n\n\n#\n\n\nDifferentialEquations.findboundary\n \n \nFunction\n.\n\n\nfindboundary(elem,bdflag=[])\n\n\nfindboundary(fem_mesh::FEMmesh,bdflag=[])\n\n\nFinds elements which are on the boundary of the domain. If bdflag is given, then those indices are added as nodes for a dirichlet boundary condition (useful for creating cracks and other cutouts of domains).\n\n\nReturns\n\n\nbdnode = Vector of indices for bdnode. Using node[:,bdnode] returns boundary nodes.\n\n\nbdedge = Vector of indices for boundary edges.\n\n\nis_bdnode = Vector of booleans size N which donotes which are on the boundary\n\n\nis_bdelem = Vector of booleans size NT which denotes which are on the boundary\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.setboundary\n \n \nFunction\n.\n\n\nsetboundary(node::AbstractArray,elem::AbstractArray,bdtype)\n\n\nsetboundary(fem_mesh::FEMmesh,bdtype)\n\n\nTakes in the fem_mesh and creates an array bdflag which denotes the boundary types. 1 stands for dirichlet, 2 for neumann, 3 for robin.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.fem_squaremesh\n \n \nFunction\n.\n\n\nfem_squaremesh(square,h)\n\n\nReturns the grid in the iFEM form of the two arrays (node,elem)\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.notime_squaremesh\n \n \nFunction\n.\n\n\nnotime_squaremesh(square,\u0394x,bdtype)\n\n\nComputes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x,\ndirichlet\n)\n\n\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.parabolic_squaremesh\n \n \nFunction\n.\n\n\nparabolic_squaremesh(square,\u0394x,\u0394t,T,bdtype)\n\n\nComputes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,:dirichlet)\n\n\n\n\nsource\n\n\n\n\nExample Meshes\n\n\n#\n\n\nDifferentialEquations.meshExample_bunny\n \n \nFunction\n.\n\n\nmeshExample_bunny() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n \n \nFunction\n.\n\n\nmeshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_lakemesh\n \n \nFunction\n.\n\n\nmeshExample_lakemesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapemesh\n \n \nFunction\n.\n\n\nmeshExample_Lshapemesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n \n \nFunction\n.\n\n\nmeshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_oilpump\n \n \nFunction\n.\n\n\nmeshExample_oilpump() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_wavymesh\n \n \nFunction\n.\n\n\nmeshExample_wavymesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n \n \nFunction\n.\n\n\nmeshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:\n\n\nplot(mesh::Mesh)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#meshes", 
            "text": "", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#mesh-specification", 
            "text": "Finite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:   Row $i$ of node is an $(x,y)$ (or $(x,y,z)$) pair which specifies the coordinates   of the $i$th node. * Row $j$ of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.  For example, to know the $(x,y)$ locations of the vertices of triangle $j$, we would see that $node[elem[j,i],:]$ are the $(x,y)$ locations of the $i$th vertex for $i=1,2,3$.  For more information, please see  Programming of Finite Element Methods by Long Chen .", 
            "title": "Mesh Specification"
        }, 
        {
            "location": "/man/mesh/#mesh-type", 
            "text": "#  DifferentialEquations.FEMmesh     Type .  FEMmesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.  bdnode : Vector of indices for the boundary nodes.  freenode : Vector of indices for the free (non-dirichlet bound) nodes.  bdedge : Indices of the edges in totaledge which are on the boundary.  is_bdnode : Boolean which is true for nodes on the boundary.  is_bdelem : Boolean which is true for elements on the boundary.  bdflag : Flag which describes the type of boundary condition. 1=  dirichlet,   2= neumann, 3= robin. *  totaledge : Vector of the edges. *  area : Vector which is the area for each element. *  dirichlet : Indices for the nodes on the boundary which have a dirichlet boundary condition. *  neumann : Indices for the nodes on the boundary which have a neumann boundary condition. *  robin : Indices for the nodes on the boundary which have a robin boundary condition. *  N::Int : The number of nodes. *  NT ::Int: The number of triangles (elements). *  \u0394x : The spatial discretization size. If non-uniform, this is the average. *  \u0394t : The time discretization size. If adaptive, this is the initial. *  T ::Number: The end time. *  numiters ::Int: The number of iterations to go from 0 to T using \u0394t. *  \u03bc : The CFL \u03bc stability parameter. *  \u03bd : The CFL \u03bd stability parameter. *  evolutionEq : True for a mesh which has non-trivial time components.  source  #  DifferentialEquations.SimpleMesh     Type .  SimpleMesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see  Programming of Finite Element Methods by Long Chen .  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.   source  #  DifferentialEquations.Mesh     Type .  Mesh: An abstract type which holds a (node,elem) pair and other information for a mesh  source", 
            "title": "Mesh Type"
        }, 
        {
            "location": "/man/mesh/#mesh-generation-functions", 
            "text": "#  DifferentialEquations.findboundary     Function .  findboundary(elem,bdflag=[])  findboundary(fem_mesh::FEMmesh,bdflag=[])  Finds elements which are on the boundary of the domain. If bdflag is given, then those indices are added as nodes for a dirichlet boundary condition (useful for creating cracks and other cutouts of domains).  Returns  bdnode = Vector of indices for bdnode. Using node[:,bdnode] returns boundary nodes.  bdedge = Vector of indices for boundary edges.  is_bdnode = Vector of booleans size N which donotes which are on the boundary  is_bdelem = Vector of booleans size NT which denotes which are on the boundary  source  #  DifferentialEquations.setboundary     Function .  setboundary(node::AbstractArray,elem::AbstractArray,bdtype)  setboundary(fem_mesh::FEMmesh,bdtype)  Takes in the fem_mesh and creates an array bdflag which denotes the boundary types. 1 stands for dirichlet, 2 for neumann, 3 for robin.  source  #  DifferentialEquations.fem_squaremesh     Function .  fem_squaremesh(square,h)  Returns the grid in the iFEM form of the two arrays (node,elem)  source  #  DifferentialEquations.notime_squaremesh     Function .  notime_squaremesh(square,\u0394x,bdtype)  Computes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.", 
            "title": "Mesh Generation Functions"
        }, 
        {
            "location": "/man/mesh/#example", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x, dirichlet )  source  #  DifferentialEquations.parabolic_squaremesh     Function .  parabolic_squaremesh(square,\u0394x,\u0394t,T,bdtype)  Computes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example_1", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,:dirichlet)  source", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example-meshes", 
            "text": "#  DifferentialEquations.meshExample_bunny     Function .  meshExample_bunny() : Returns a 3D SimpleMesh.  source  #  DifferentialEquations.meshExample_flowpastcylindermesh     Function .  meshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.  source  #  DifferentialEquations.meshExample_lakemesh     Function .  meshExample_lakemesh() : Returns a 2D SimpleMesh.  source  #  DifferentialEquations.meshExample_Lshapemesh     Function .  meshExample_Lshapemesh() : Returns a 2D SimpleMesh.  source  #  DifferentialEquations.meshExample_Lshapeunstructure     Function .  meshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.  source  #  DifferentialEquations.meshExample_oilpump     Function .  meshExample_oilpump() : Returns a 3D SimpleMesh.  source  #  DifferentialEquations.meshExample_wavymesh     Function .  meshExample_wavymesh() : Returns a 2D SimpleMesh.  source  #  DifferentialEquations.meshExample_wavyperturbmesh     Function .  meshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.  source", 
            "title": "Example Meshes"
        }, 
        {
            "location": "/man/mesh/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:  plot(mesh::Mesh)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/solution/", 
            "text": "The Solution Type\n\n\nEach solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled \nsave_timeseries=true\n, then the solver also includes a time-course of the solution captured at every \ntimeseries_steps\n steps.\n\n\nThe solution type has a lot of built in functionality to help analysis. For example, it has an array interface for accessing the values. We can use\n\n\nsol[i]\n\n\n\n\nto access the value at timestep \ni\n (if the timeseres was saved), and\n\n\nsol.t[i]\n\n\n\n\nto access the value of \nt\n at timestep \ni\n. The final value of the simulation, which is always saved, is saved to\n\n\nsol.u\n\n\n\n\nIf the analytical solution, we also have\n\n\nsol.u_analytic # final value\nsol.timeseries_analytic # timeseries of analytical solution, saved if save_timesseries == true\n\n\n\n\nPlotting functionality is provided for each solution type. To plot the solution, simply use\n\n\nplot(sol)\n\n\n\n\nThe plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.\n\n\n\n\nSolution Types\n\n\n#\n\n\nDifferentialEquations.FEMSolution\n \n \nType\n.\n\n\nFEMSolution\n\n\nHolds the data for the solution to a finite element problem.\n\n\nFields\n\n\n\n\nfem_mesh::FEMmesh\n: The finite element mesh the problem was solved on.\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.DESolution\n \n \nType\n.\n\n\nPdeSolution: Wrapper for the objects obtained from a solver\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.SDESolution\n \n \nType\n.\n\n\nSDESolution\n\n\nHolds the data for the solution to a SDE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \nWs\n: All of the W's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \ntimeseries_analytic\n: If \nsave_timeseries=true\n, saves the solution at each save point. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints. * \nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.ODESolution\n \n \nType\n.\n\n\nODESolution\n\n\nHolds the data for the solution to an ODE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \ntimeseries_analytic\n: If \nsave_timeseries=true\n, saves the solution at each timestep. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints. * \nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.StokesSolution\n \n \nType\n.\n\n\nStokesSolution\n\n\nHolds the data for the solution to a Stokes problem.\n\n\nFields\n\n\n\n\nu\n\n\nv\n\n\np\n\n\nu_analytic\n\n\nvTrue\n\n\npTrue\n\n\nmesh\n\n\ntrueknown\n\n\nerrors\n\n\nconverrors\n\n\n\n\nsource\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.appxTrue!\n \n \nFunction\n.\n\n\nappxTrue!(res,res2)\n\n\nAdds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.FEMSolutionTS\n \n \nFunction\n.\n\n\nS = FEMSolutionTS(timeseries::GrowableArray,numvars::Int) S[i][j] =\n Variable i at time j.\n\n\nsource", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#the-solution-type", 
            "text": "Each solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled  save_timeseries=true , then the solver also includes a time-course of the solution captured at every  timeseries_steps  steps.  The solution type has a lot of built in functionality to help analysis. For example, it has an array interface for accessing the values. We can use  sol[i]  to access the value at timestep  i  (if the timeseres was saved), and  sol.t[i]  to access the value of  t  at timestep  i . The final value of the simulation, which is always saved, is saved to  sol.u  If the analytical solution, we also have  sol.u_analytic # final value\nsol.timeseries_analytic # timeseries of analytical solution, saved if save_timesseries == true  Plotting functionality is provided for each solution type. To plot the solution, simply use  plot(sol)  The plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#solution-types", 
            "text": "#  DifferentialEquations.FEMSolution     Type .  FEMSolution  Holds the data for the solution to a finite element problem.  Fields   fem_mesh::FEMmesh : The finite element mesh the problem was solved on.  u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints.  source  #  DifferentialEquations.DESolution     Type .  PdeSolution: Wrapper for the objects obtained from a solver  source  #  DifferentialEquations.SDESolution     Type .  SDESolution  Holds the data for the solution to a SDE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  Ws : All of the W's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  timeseries_analytic : If  save_timeseries=true , saves the solution at each save point. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints. *  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  source  #  DifferentialEquations.ODESolution     Type .  ODESolution  Holds the data for the solution to an ODE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  timeseries_analytic : If  save_timeseries=true , saves the solution at each timestep. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints. *  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  source  #  DifferentialEquations.StokesSolution     Type .  StokesSolution  Holds the data for the solution to a Stokes problem.  Fields   u  v  p  u_analytic  vTrue  pTrue  mesh  trueknown  errors  converrors   source", 
            "title": "Solution Types"
        }, 
        {
            "location": "/man/solution/#related-functions", 
            "text": "#  DifferentialEquations.appxTrue!     Function .  appxTrue!(res,res2)  Adds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution  source  #  DifferentialEquations.FEMSolutionTS     Function .  S = FEMSolutionTS(timeseries::GrowableArray,numvars::Int) S[i][j] =  Variable i at time j.  source", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/plot/", 
            "text": "Plot Functions\n\n\n\n\nStandard Plots\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nsave_timeseries\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using \nall of the keyword arguments provided by Plots.jl\n. Please see \nPlots.jl's documentation\n for more information.\n\n\nA few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:\n\n\n\n\nplot_analytic: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.\n\n\nfilename: Specifies the filename to save an animation. Only applies to the \nanimate\n function.\n\n\nfps: Determines the fps in an animation. Only applies to the \nanimate\n function.\n\n\n\n\n\n\nExtra Plot Functions\n\n\n#\n\n\nDifferentialEquations.animate\n \n \nFunction\n.\n\n\nanimate(sol::FEMSolution)\n\n\nPlots an animation of the solution. Requires \nsave_timeseries=true\n was enabled in the solver.\n\n\nsource", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#plot-functions", 
            "text": "", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#standard-plots", 
            "text": "Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  save_timeseries  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using  all of the keyword arguments provided by Plots.jl . Please see  Plots.jl's documentation  for more information.  A few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:   plot_analytic: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.  filename: Specifies the filename to save an animation. Only applies to the  animate  function.  fps: Determines the fps in an animation. Only applies to the  animate  function.", 
            "title": "Standard Plots"
        }, 
        {
            "location": "/man/plot/#extra-plot-functions", 
            "text": "#  DifferentialEquations.animate     Function .  animate(sol::FEMSolution)  Plots an animation of the solution. Requires  save_timeseries=true  was enabled in the solver.  source", 
            "title": "Extra Plot Functions"
        }, 
        {
            "location": "/man/convergence/", 
            "text": "Convergence Simulations\n\n\nThe convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.\n\n\nOne can automatically have DifferentialEquations.jl perform the error analysis by passing a \nConvergenceSimulation\n a vector of solutions, or using one of the provided \ntest_convergence\n functions. These will give order of convergence estimates and provide plotting functionality. This requires that the true solution was provided in the problem definition.\n\n\nConvergenceSimulation\ns can either be created by passing the constructor the appropriate solution array or by using one of the provided \ntest_convergence\n functions.\n\n\n\n\nThe ConvergenceSimulation Type\n\n\n#\n\n\nDifferentialEquations.ConvergenceSimulation\n \n \nType\n.\n\n\nConvergenceSimulation\n\n\nA type which holds the data from a convergence simulation.\n\n\nFields\n\n\n\n\nsolutions::Array{DESolution}\n: Holds all the PdeSolutions.\n\n\nerrors\n: Dictionary of the error calculations. Can contain: * \nh1Errors\n: Vector of the H1 errors. * \nl2Errors\n: Vector of the L2 errors. * \nmaxErrors\n: Vector of the nodal maximum errors. * \nnode2Errors\n: Vector of the nodal l2 errors.\n\n\nN\n: The number of simulations.\n\n\nauxdata\n: Auxillary data of the convergence simluation. Entries can include: * \n\u0394ts\n: The \u0394t's in the simulations. * \n\u0394xs\n: The \u0394x's in the simulations. * \n\u03bcs\n: The CFL \u03bc's in the simulations. * \n\u03bds\n: The CFL \u03bd's in the simulations.\n\n\n\ud835\udcaaest\n: Dictionary of order estimates. Can contain: * \nConvEst_h1\n: The H1 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1) * \nConvEst_l2\n: The L2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2) * \nConvEst_max\n: The nodal maximum error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max) * \nConvEst_node2\n: The nodal l2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)\n\n\nconvergence_axis\n: The axis along which convergence is calculated. For example, if we calculate the \u0394t convergence, convergence_axis is the \u0394ts used in the calculation.\n\n\n\n\nsource\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:\n\n\nplot(sim::ConvergenceSimulation)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.\n\n\n\n\nRelated Functions\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n \n \nFunction\n.\n\n\ncalc\ud835\udcaaestimates(error::Vector{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.test_convergence\n \n \nFunction\n.\n\n\ntest_convergence(\u0394ts::AbstractArray,prob::SDEProblem)\n\n\nTests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nnumMonte\n: The number of simulations for each \u0394t. Default is 10000.\n\n\nsave_timeseries\n: Denotes whether to save at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes the steps to save at if \nsave_timeseries=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"EM\".\n\n\n\n\nsource\n\n\ntest_convergence(\u0394ts::AbstractArray,prob::ODEProblem)\n\n\nTests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nsave_timeseries\n: Denotes whether to save at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes the steps to save at if \nsave_timeseries=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"Euler\".\n\n\ntableau\n: The tableau used for generic methods. Defaults to ODE_DEFAULT_TABLEAU.\n\n\n\n\nsource\n\n\ntest_convergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergence_axis)\n\n\nTests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence, \nconvergence_axis = \u0394ts\n.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Defaults to 1\n\n\nalg\n: The algorithm to test. Default is \"Euler\".\n\n\n\n\nsource\n\n\ntest_convergence(\u0394xs::AbstractArray,prob::PoissonProblem)\n\n\nTests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].\n\n\nKeyword Arguments\n\n\n\n\nsolver\n: Which solver to use. Default is \"Direct\".\n\n\n\n\nsource", 
            "title": "Convergence Simuations"
        }, 
        {
            "location": "/man/convergence/#convergence-simulations", 
            "text": "The convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.  One can automatically have DifferentialEquations.jl perform the error analysis by passing a  ConvergenceSimulation  a vector of solutions, or using one of the provided  test_convergence  functions. These will give order of convergence estimates and provide plotting functionality. This requires that the true solution was provided in the problem definition.  ConvergenceSimulation s can either be created by passing the constructor the appropriate solution array or by using one of the provided  test_convergence  functions.", 
            "title": "Convergence Simulations"
        }, 
        {
            "location": "/man/convergence/#the-convergencesimulation-type", 
            "text": "#  DifferentialEquations.ConvergenceSimulation     Type .  ConvergenceSimulation  A type which holds the data from a convergence simulation.  Fields   solutions::Array{DESolution} : Holds all the PdeSolutions.  errors : Dictionary of the error calculations. Can contain: *  h1Errors : Vector of the H1 errors. *  l2Errors : Vector of the L2 errors. *  maxErrors : Vector of the nodal maximum errors. *  node2Errors : Vector of the nodal l2 errors.  N : The number of simulations.  auxdata : Auxillary data of the convergence simluation. Entries can include: *  \u0394ts : The \u0394t's in the simulations. *  \u0394xs : The \u0394x's in the simulations. *  \u03bcs : The CFL \u03bc's in the simulations. *  \u03bds : The CFL \u03bd's in the simulations.  \ud835\udcaaest : Dictionary of order estimates. Can contain: *  ConvEst_h1 : The H1 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1) *  ConvEst_l2 : The L2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2) *  ConvEst_max : The nodal maximum error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max) *  ConvEst_node2 : The nodal l2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)  convergence_axis : The axis along which convergence is calculated. For example, if we calculate the \u0394t convergence, convergence_axis is the \u0394ts used in the calculation.   source", 
            "title": "The ConvergenceSimulation Type"
        }, 
        {
            "location": "/man/convergence/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:  plot(sim::ConvergenceSimulation)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/convergence/#related-functions", 
            "text": "#  Base.length     Method .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  source  #  DifferentialEquations.calc\ud835\udcaaestimates     Function .  calc\ud835\udcaaestimates(error::Vector{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates  source  #  DifferentialEquations.test_convergence     Function .  test_convergence(\u0394ts::AbstractArray,prob::SDEProblem)  Tests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  numMonte : The number of simulations for each \u0394t. Default is 10000.  save_timeseries : Denotes whether to save at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes the steps to save at if  save_timeseries=true . Default is 1  alg : The algorithm to test. Defaults to \"EM\".   source  test_convergence(\u0394ts::AbstractArray,prob::ODEProblem)  Tests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  save_timeseries : Denotes whether to save at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes the steps to save at if  save_timeseries=true . Default is 1  alg : The algorithm to test. Defaults to \"Euler\".  tableau : The tableau used for generic methods. Defaults to ODE_DEFAULT_TABLEAU.   source  test_convergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergence_axis)  Tests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence,  convergence_axis = \u0394ts .  Keyword Arguments   T : The final time. Defaults to 1  alg : The algorithm to test. Default is \"Euler\".   source  test_convergence(\u0394xs::AbstractArray,prob::PoissonProblem)  Tests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].  Keyword Arguments   solver : Which solver to use. Default is \"Direct\".   source", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/conditional_dependencies/", 
            "text": "Conditional Dependencies\n\n\nDifferentialEquations.jl is conditionally dependent on some packages which may not be required for all users. The upside is that you can run DifferentialEquations.jl without installing these packages. However, the downside is that you will have to do the installation yourself (normal dependencies do a silent install). Luckily DifferentialEquations.jl warns you about missing dependencies when calling a method which requires one. This part of the manual will detail how to see if you're missing a conditional dependency and how to alleviate the issue.\n\n\n\n\nThe Conditional Dependency Notification\n\n\nWhen a conditional dependency is required, DifferentialEquations.jl will import the package the first time the method is called. When this happens, you will receive a notification as follows:\n\n\n[DifferentialEquations.jl] Initializing backend: PkgName\n\n\n\n\nwhere PkgName is the name of the package it is importing. DifferentialEquations.jl will then run a standard startup procedure on this package. If it fails, you will receive the message\n\n\nWARNING: Couldn't initialize PkgName.  (might need to install it?)\n\n\n\n\nMost likely the issue is that you need to install the package. Go to the package's Github repository for information on installing the package, and then come back to try again. If that does not work, you may need the latest version of the package by checking out master:\n\n\nPkg.checkout(\nPkgName\n)\n\n\n\n\nIf all else fails, please ask for help on \nvia the repository Gitter\n.\n\n\n\n\nWhat Methods Require Conditional Dependencies?\n\n\nThat's a good question! The implicit algorithms implemented in DifferentialEquations.jl require \nNLsolve.jl\n. Also, the \nload\n function for the premade meshes requires \nJLD.jl\n.\n\n\nLastly, there is a special conditional dependency for \nJuno\n. If you are using Juno, then the progress bar functionality is works. If you're not using Juno, then it won't do anything.\n\n\nThe other conditional dependencies are external solvers wrapped by DifferentialEquations.jl Currently these include:\n\n\n\n\nODE.jl\n\n\nODEInterface.jl\n\n\nSundials.jl\n\n\n\n\n\n\nInstallation Instructions\n\n\nFor most of the conditional dependencies, the installation instructions are standard. However, for some of the newest features, special instructions may be required. The best way to stay up-to-date on this information is to checkout the following resources:\n\n\n\n\nThe packages which are conditional dependencies and use a standard installation can be found in the \n/test/REQUIRE\n file.\n\n\nAny special installation instructions are handled via \nthe ci_setup.jl file\n.\n\n\n\n\nThe current special installation instructions are as follows:\n\n\n\n\nODE.jl.\n\n\nThe wrapper currently only works on the development branch of ODE.jl at JuliaODE/ODE.jl. To install this version of ODE.jl, use the following commands:\n\n\nPkg.clone(\nhttps://github.com/JuliaODE/ODE.jl\n)", 
            "title": "Conditional Dependencies"
        }, 
        {
            "location": "/man/conditional_dependencies/#conditional-dependencies", 
            "text": "DifferentialEquations.jl is conditionally dependent on some packages which may not be required for all users. The upside is that you can run DifferentialEquations.jl without installing these packages. However, the downside is that you will have to do the installation yourself (normal dependencies do a silent install). Luckily DifferentialEquations.jl warns you about missing dependencies when calling a method which requires one. This part of the manual will detail how to see if you're missing a conditional dependency and how to alleviate the issue.", 
            "title": "Conditional Dependencies"
        }, 
        {
            "location": "/man/conditional_dependencies/#the-conditional-dependency-notification", 
            "text": "When a conditional dependency is required, DifferentialEquations.jl will import the package the first time the method is called. When this happens, you will receive a notification as follows:  [DifferentialEquations.jl] Initializing backend: PkgName  where PkgName is the name of the package it is importing. DifferentialEquations.jl will then run a standard startup procedure on this package. If it fails, you will receive the message  WARNING: Couldn't initialize PkgName.  (might need to install it?)  Most likely the issue is that you need to install the package. Go to the package's Github repository for information on installing the package, and then come back to try again. If that does not work, you may need the latest version of the package by checking out master:  Pkg.checkout( PkgName )  If all else fails, please ask for help on  via the repository Gitter .", 
            "title": "The Conditional Dependency Notification"
        }, 
        {
            "location": "/man/conditional_dependencies/#what-methods-require-conditional-dependencies", 
            "text": "That's a good question! The implicit algorithms implemented in DifferentialEquations.jl require  NLsolve.jl . Also, the  load  function for the premade meshes requires  JLD.jl .  Lastly, there is a special conditional dependency for  Juno . If you are using Juno, then the progress bar functionality is works. If you're not using Juno, then it won't do anything.  The other conditional dependencies are external solvers wrapped by DifferentialEquations.jl Currently these include:   ODE.jl  ODEInterface.jl  Sundials.jl", 
            "title": "What Methods Require Conditional Dependencies?"
        }, 
        {
            "location": "/man/conditional_dependencies/#installation-instructions", 
            "text": "For most of the conditional dependencies, the installation instructions are standard. However, for some of the newest features, special instructions may be required. The best way to stay up-to-date on this information is to checkout the following resources:   The packages which are conditional dependencies and use a standard installation can be found in the  /test/REQUIRE  file.  Any special installation instructions are handled via  the ci_setup.jl file .   The current special installation instructions are as follows:", 
            "title": "Installation Instructions"
        }, 
        {
            "location": "/man/conditional_dependencies/#odejl", 
            "text": "The wrapper currently only works on the development branch of ODE.jl at JuliaODE/ODE.jl. To install this version of ODE.jl, use the following commands:  Pkg.clone( https://github.com/JuliaODE/ODE.jl )", 
            "title": "ODE.jl."
        }, 
        {
            "location": "/man/progress_bar/", 
            "text": "Juno Progress Bar Integration\n\n\nDifferentialEquations.jl integrates with the Juno progress bar in order to make long calculations more manageable. By default this feature is off for ODE and SDE solvers, but can be turned on via the keyword argument \nprogressbar=true\n. The progress bar updates every \nprogress_steps\n timesteps, which has a default value of 1000. Note that making this value really low could cause a performance hit, though from some basic testing it seems that with updates at around 1000 steps there's no discernable performance degradation.", 
            "title": "Juno Progress Bar Integration"
        }, 
        {
            "location": "/man/progress_bar/#juno-progress-bar-integration", 
            "text": "DifferentialEquations.jl integrates with the Juno progress bar in order to make long calculations more manageable. By default this feature is off for ODE and SDE solvers, but can be turned on via the keyword argument  progressbar=true . The progress bar updates every  progress_steps  timesteps, which has a default value of 1000. Note that making this value really low could cause a performance hit, though from some basic testing it seems that with updates at around 1000 steps there's no discernable performance degradation.", 
            "title": "Juno Progress Bar Integration"
        }, 
        {
            "location": "/internals/contributors_guide/", 
            "text": "Contributor's Guide\n\n\nSo you're looking to help out DifferentialEquations.jl? We'd be happy to have your help. It is recommended you first discuss with some of the developers \non the Gitter channel\n to make sure that you're up-to-date with current developments.\n\n\n\n\nDeveloping New Solver Algorithms\n\n\nThe easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the \"hot loop\". For example, take a look at the ODE solver code. The mode \nsolve(::ODEProblem,::AbstractArray)\n is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in ode_integrators.jl. For example, take a look at the Midpoint method's implementation:\n\n\nfunction ode_midpoint(f::Function,u::AbstractArray,t,\u0394t,T,iter,\n                      maxiters,timeseries,ts,timeseries_steps,save_timeseries,adaptive,progressbar)\n  half\u0394t = \u0394t/2\n  utilde = similar(u)\n  while t \n T\n    @ode_loopheader\n    utilde[:] = u+half\u0394t.*f(u,t)\n    u = u + \u0394t.*f(utilde,t+half\u0394t)\n    @ode_loopfooter\n  end\n  return u,t,timeseries,ts\nend\n\n\n\n\nThe parts in the signature are the items you have available. Most are self-explanatory (they are from the ODE problem). The extra are for parts of the header and footer for exiting at max iterations, and plugging into the Juno progressbar. These are done in the \n@ode_loopheader\n and \n@ode_loopfooter\n macros, which are defined using the \n@def\n macro (they essentially copy-paste the code from the line which says \n@def ode_loopheader begin ... end\n). Note that the loopfooter code takes care of the code for doing the adaptive timestepping. All that is required for the adaptivity is that the algorithm computes an error estimate \nEEst\n each time, save the value \nutmp\n to be what will replace \nu\n if the step is not rejected, and add the algorithm's symbol is added to the dictionary \nODE_DIFFERENTIALEQUATIONSJL_ADAPTIVEALGS\n in \node_constants.jl\n. If implicit solving is needed (via NLsolve), add the algorithm's symbol to \nDIFFERENTIALEQUATIONSJL_IMPLICITALGS\n and the conditional dependency will be supplied. Note that you may need more function arguments. Use another method as a template.\n\n\nWhen the solver is completed, add a call to the solver in the glue code \nsolve(::ODEProblem,::AbstractArray)\n (you will see all the others), add the symbol for the algorithm to \nDIFFERENTIALEQUATIONSJL_ALGORITHMS\n, and the order to \nDIFFERENTIALEQUATIONSJL_ORDERS\n. It's that quick! Lastly, add your method to the convergence tests in the appropriate /test file.  Feel free to implement any interesting or educational algorithm: they don't have to be the fastest and it is always is useful to have such algorithms (like Simpson's method) available for demonstration purposes.\n\n\nAdding algorithms to the other problems is very similar.\n\n\n\n\nAdding Conditional Dependencies\n\n\nIf your algorithm requires a conditional dependency (a package, but not one that everyone who uses DifferentialEquations.jl would need), you can add them as follows. Before the loop, add the line \ninitialize_backend(:PkgName)\n where \n:PkgName\n is the same name as the package you wish to use. Then, in \ngeneral/backends.jl\n add a dispatch to \ninit_package\n. A common one would be:\n\n\ninit_package(b::backend{:PkgName}) = @eval begin\n      import PkgName\n      export PkgName\n    end\n\n\n\n\nNow inside your method you can use any function from the package via PkgName.function. The first time it is used it import the package (or tell the user to install it).\n\n\n\n\nDeveloping A New Problem\n\n\nTo develop a new problem, you need to make a new \nDEProblem\n and a new \nDESolution\n. The \nDEProblem\n type should hold all of the mathematical information about the problem, and the \nDESolution\n should hold all of the information for the solution. Then all that is required is to define a \nsolve(::DEProblem,*Extra Mesh Things*;kwargs)\n which takes in the problem and returns a solution. To add plotting functionality, add a plot recipe for the solution type to \n/general/plotrecipes\n. For testing that the algorithm works, add a dispatch for \ntest_convergence\n which makes a \nConvergenceSimulation\n type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field \nerrors\n which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)\n\n\n\n\nOther Help\n\n\nThere's always more to be. Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see \"which is best\". Adding examples IJulia notebooks to \n/examples/\n is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/internals/contributors_guide/#contributors-guide", 
            "text": "So you're looking to help out DifferentialEquations.jl? We'd be happy to have your help. It is recommended you first discuss with some of the developers  on the Gitter channel  to make sure that you're up-to-date with current developments.", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/internals/contributors_guide/#developing-new-solver-algorithms", 
            "text": "The easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the \"hot loop\". For example, take a look at the ODE solver code. The mode  solve(::ODEProblem,::AbstractArray)  is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in ode_integrators.jl. For example, take a look at the Midpoint method's implementation:  function ode_midpoint(f::Function,u::AbstractArray,t,\u0394t,T,iter,\n                      maxiters,timeseries,ts,timeseries_steps,save_timeseries,adaptive,progressbar)\n  half\u0394t = \u0394t/2\n  utilde = similar(u)\n  while t   T\n    @ode_loopheader\n    utilde[:] = u+half\u0394t.*f(u,t)\n    u = u + \u0394t.*f(utilde,t+half\u0394t)\n    @ode_loopfooter\n  end\n  return u,t,timeseries,ts\nend  The parts in the signature are the items you have available. Most are self-explanatory (they are from the ODE problem). The extra are for parts of the header and footer for exiting at max iterations, and plugging into the Juno progressbar. These are done in the  @ode_loopheader  and  @ode_loopfooter  macros, which are defined using the  @def  macro (they essentially copy-paste the code from the line which says  @def ode_loopheader begin ... end ). Note that the loopfooter code takes care of the code for doing the adaptive timestepping. All that is required for the adaptivity is that the algorithm computes an error estimate  EEst  each time, save the value  utmp  to be what will replace  u  if the step is not rejected, and add the algorithm's symbol is added to the dictionary  ODE_DIFFERENTIALEQUATIONSJL_ADAPTIVEALGS  in  ode_constants.jl . If implicit solving is needed (via NLsolve), add the algorithm's symbol to  DIFFERENTIALEQUATIONSJL_IMPLICITALGS  and the conditional dependency will be supplied. Note that you may need more function arguments. Use another method as a template.  When the solver is completed, add a call to the solver in the glue code  solve(::ODEProblem,::AbstractArray)  (you will see all the others), add the symbol for the algorithm to  DIFFERENTIALEQUATIONSJL_ALGORITHMS , and the order to  DIFFERENTIALEQUATIONSJL_ORDERS . It's that quick! Lastly, add your method to the convergence tests in the appropriate /test file.  Feel free to implement any interesting or educational algorithm: they don't have to be the fastest and it is always is useful to have such algorithms (like Simpson's method) available for demonstration purposes.  Adding algorithms to the other problems is very similar.", 
            "title": "Developing New Solver Algorithms"
        }, 
        {
            "location": "/internals/contributors_guide/#adding-conditional-dependencies", 
            "text": "If your algorithm requires a conditional dependency (a package, but not one that everyone who uses DifferentialEquations.jl would need), you can add them as follows. Before the loop, add the line  initialize_backend(:PkgName)  where  :PkgName  is the same name as the package you wish to use. Then, in  general/backends.jl  add a dispatch to  init_package . A common one would be:  init_package(b::backend{:PkgName}) = @eval begin\n      import PkgName\n      export PkgName\n    end  Now inside your method you can use any function from the package via PkgName.function. The first time it is used it import the package (or tell the user to install it).", 
            "title": "Adding Conditional Dependencies"
        }, 
        {
            "location": "/internals/contributors_guide/#developing-a-new-problem", 
            "text": "To develop a new problem, you need to make a new  DEProblem  and a new  DESolution . The  DEProblem  type should hold all of the mathematical information about the problem, and the  DESolution  should hold all of the information for the solution. Then all that is required is to define a  solve(::DEProblem,*Extra Mesh Things*;kwargs)  which takes in the problem and returns a solution. To add plotting functionality, add a plot recipe for the solution type to  /general/plotrecipes . For testing that the algorithm works, add a dispatch for  test_convergence  which makes a  ConvergenceSimulation  type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field  errors  which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)", 
            "title": "Developing A New Problem"
        }, 
        {
            "location": "/internals/contributors_guide/#other-help", 
            "text": "There's always more to be. Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see \"which is best\". Adding examples IJulia notebooks to  /examples/  is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!", 
            "title": "Other Help"
        }, 
        {
            "location": "/internals/fem_tools/", 
            "text": "Internal Finite Element Tools\n\n\n\n\nMesh Tools\n\n\n#\n\n\nDifferentialEquations.CFL\u03bd\n \n \nFunction\n.\n\n\nCFL\u03bd(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bd= \u0394t/\u0394x\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.CFL\u03bc\n \n \nFunction\n.\n\n\nCFL\u03bc(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)\n\n\nsource\n\n\n\n\nSolver Tools\n\n\n#\n\n\nDifferentialEquations.\u2207basis\n \n \nFunction\n.\n\n\n\u2207basis(node,elem)\n\n\nReturns the \u2207u of the barycentric basis elements.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.quadfbasis\n \n \nFunction\n.\n\n\nquadfbasis(f,gD,gN,A,u,node,elem,area,bdnode,mid,N,NT,dirichlet,neumann,islinear,numvars;gNquad\ud835\udcaa=2)\n\n\nPerforms the order 2 quadrature to calculate the vector from the term $\n<f\n,v>$ for linear elements.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.quadpts\n \n \nFunction\n.\n\n\nquadpts(\ud835\udcaa)\n\n\nReturns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.\n\n\nReference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.quadpts1\n \n \nFunction\n.\n\n\nquadpts1(\ud835\udcaa)\n\n\nReferences: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.assemblematrix\n \n \nFunction\n.\n\n\nassemblematrix(node,elem;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nsource\n\n\nassemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.\u2207u\n \n \nFunction\n.\n\n\n\u2207u(node,elem,u,D\u03bb=[])\n\n\nEstimates \u2207u of u on the mesh (node,elem)\n\n\nsource\n\n\n\n\nError Tools\n\n\n#\n\n\nDifferentialEquations.getH1error\n \n \nFunction\n.\n\n\nfunction getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])\n\n\ngetH1error(fem_mesh::FEMmesh,Du,u)\n\n\nEstimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.getL2error\n \n \nFunction\n.\n\n\ngetL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])\n\n\ngetL2error(fem_mesh::FEMmesh,sol,u)\n\n\nEstimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.\n\n\nsource", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/fem_tools/#internal-finite-element-tools", 
            "text": "", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/fem_tools/#mesh-tools", 
            "text": "#  DifferentialEquations.CFL\u03bd     Function .  CFL\u03bd(\u0394t,\u0394x)  Computes the CFL-condition \u03bd= \u0394t/\u0394x  source  #  DifferentialEquations.CFL\u03bc     Function .  CFL\u03bc(\u0394t,\u0394x)  Computes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)  source", 
            "title": "Mesh Tools"
        }, 
        {
            "location": "/internals/fem_tools/#solver-tools", 
            "text": "#  DifferentialEquations.\u2207basis     Function .  \u2207basis(node,elem)  Returns the \u2207u of the barycentric basis elements.  source  #  DifferentialEquations.quadfbasis     Function .  quadfbasis(f,gD,gN,A,u,node,elem,area,bdnode,mid,N,NT,dirichlet,neumann,islinear,numvars;gNquad\ud835\udcaa=2)  Performs the order 2 quadrature to calculate the vector from the term $ <f ,v>$ for linear elements.  source  #  DifferentialEquations.quadpts     Function .  quadpts(\ud835\udcaa)  Returns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.  Reference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.  source  #  DifferentialEquations.quadpts1     Function .  quadpts1(\ud835\udcaa)  References: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/  source  #  DifferentialEquations.assemblematrix     Function .  assemblematrix(node,elem;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  source  assemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  source  #  DifferentialEquations.\u2207u     Function .  \u2207u(node,elem,u,D\u03bb=[])  Estimates \u2207u of u on the mesh (node,elem)  source", 
            "title": "Solver Tools"
        }, 
        {
            "location": "/internals/fem_tools/#error-tools", 
            "text": "#  DifferentialEquations.getH1error     Function .  function getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])  getH1error(fem_mesh::FEMmesh,Du,u)  Estimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.  source  #  DifferentialEquations.getL2error     Function .  getL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])  getL2error(fem_mesh::FEMmesh,sol,u)  Estimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.  source", 
            "title": "Error Tools"
        }, 
        {
            "location": "/internals/extras/", 
            "text": "Extra Functions\n\n\n#\n\n\nDifferentialEquations.getNoise\n \n \nFunction\n.\n\n\ngetNoise(N,node,elem;noisetype=:White)\n\n\nReturns a random vector corresponding to the noise type which was chosen.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.numparameters\n \n \nFunction\n.\n\n\nnumparameters(f)\n\n\nReturns the number of parameters of \nf\n for the method which has the most parameters.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.Tableau\n \n \nType\n.\n\n\nTableau: Holds the information for a Runge-Kutta Tableau\n\n\nsource", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#extra-functions", 
            "text": "#  DifferentialEquations.getNoise     Function .  getNoise(N,node,elem;noisetype=:White)  Returns a random vector corresponding to the noise type which was chosen.  source  #  DifferentialEquations.numparameters     Function .  numparameters(f)  Returns the number of parameters of  f  for the method which has the most parameters.  source  #  DifferentialEquations.Tableau     Type .  Tableau: Holds the information for a Runge-Kutta Tableau  source", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/solver_helpers/", 
            "text": "Solver Helpers\n\n\nThis package includes the documentation for the helper functions for the various solvers.\n\n\n\n\nODE Solver Extras\n\n\nBase.length(::ExplicitRKTableau)\nDifferentialEquations.ExplicitRKTableau\nDifferentialEquations.ODE_DEFAULT_TABLEAU\nDifferentialEquations.constructCashKarp\nDifferentialEquations.constructRalston\nDifferentialEquations.constructDormandPrince\nDifferentialEquations.constructDormandPrince8\nDifferentialEquations.constructBogakiShampine\nDifferentialEquations.constructHuen\nDifferentialEquations.constructRKF\nDifferentialEquations.constructRKF8\n\n\n\n\n\n\nSDE Solver Extras\n\n\n#\n\n\nDifferentialEquations.monteCarloSim\n \n \nFunction\n.\n\n\nmonteCarloSim(\u0394t::Number,prob::SDEProblem)\n\n\nPerforms a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.\n\n\nKeyword Arguments\n\n\n\n\nT - Final time. Default is 1.\n\n\nnumMonte - Number of Monte-Carlo simulations to run. Default is 10000\n\n\nsave_timeseries - Denotes whether save_timeseries should be turned on in each run. Default is true.\n\n\nalg - Algorithm for solving the SDEs. Default is \"EM\"\n\n\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.RosslerSRI\n \n \nType\n.\n\n\nRosslerSRI\n\n\nHolds the Butcher tableaus for a Rosser SRI method.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.RosslerSRA\n \n \nType\n.\n\n\nRosslerSRA\n\n\nHolds the Butcher tableaus for a Rosser SRA method.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.constructSRA1\n \n \nFunction\n.\n\n\nconstructSRA1()\n\n\nConstructs the taleau type for the SRA1 method.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.constructSRIW1\n \n \nFunction\n.\n\n\nconstructSRIW1()\n\n\nConstructs the tableau type for the SRIW1 method.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.checkSRAOrder\n \n \nFunction\n.\n\n\ncheckSRAOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRA method.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.checkSRIOrder\n \n \nFunction\n.\n\n\ncheckSRIOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRI method.\n\n\nsource\n\n\n\n\nStationary Stokes\n\n\n#\n\n\nDifferentialEquations.GS\u03b4q!\n \n \nFunction\n.\n\n\nGS\u03b4q!(\u03b4q,rp,\u0394xs)\n\n\nPerforms a Gauss-Seidel iteration for \u03b4q.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.GSu!\n \n \nFunction\n.\n\n\nGSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)\n\n\nPerforms a Gauss-Seidel iteration on u.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.calc_rp!\n \n \nFunction\n.\n\n\ncalc_rp!(rp,u,v,\u0394xs,g,px,py)\n\n\nCalculates the rp from the u and v's.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.update_p!\n \n \nFunction\n.\n\n\nupdate_p!(p,\u03b4q,\u0394xs)\n\n\nUpdates p given \u03b4q\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.update_v!\n \n \nFunction\n.\n\n\nupdate_v!(v,\u03b4q,\u0394xs)\n\n\nUpdates v given \u03b4q\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.uzawa_p!\n \n \nFunction\n.\n\n\nuzawa_p!(p,u,v,\u0394xs,g,px,py)\n\n\nSolves for p from u and v using an Uzawa update.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.stokes_restriction\n \n \nFunction\n.\n\n\nstokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nRestricts the Stokes problem to the coarsegrid.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.stokes_prolongation\n \n \nFunction\n.\n\n\nstokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nProlongates the Stokes problem to the fine grid\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.update_u!\n \n \nFunction\n.\n\n\nupdate_u!(u,\u03b4q,\u0394xs)\n\n\nUpdates u given \u03b4q\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.GSv!\n \n \nFunction\n.\n\n\nGSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)\n\n\nPerforms a Gauss-Seidel iteration on v.\n\n\nsource", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solver_helpers/#solver-helpers", 
            "text": "This package includes the documentation for the helper functions for the various solvers.", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solver_helpers/#ode-solver-extras", 
            "text": "Base.length(::ExplicitRKTableau)\nDifferentialEquations.ExplicitRKTableau\nDifferentialEquations.ODE_DEFAULT_TABLEAU\nDifferentialEquations.constructCashKarp\nDifferentialEquations.constructRalston\nDifferentialEquations.constructDormandPrince\nDifferentialEquations.constructDormandPrince8\nDifferentialEquations.constructBogakiShampine\nDifferentialEquations.constructHuen\nDifferentialEquations.constructRKF\nDifferentialEquations.constructRKF8", 
            "title": "ODE Solver Extras"
        }, 
        {
            "location": "/internals/solver_helpers/#sde-solver-extras", 
            "text": "#  DifferentialEquations.monteCarloSim     Function .  monteCarloSim(\u0394t::Number,prob::SDEProblem)  Performs a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.  Keyword Arguments   T - Final time. Default is 1.  numMonte - Number of Monte-Carlo simulations to run. Default is 10000  save_timeseries - Denotes whether save_timeseries should be turned on in each run. Default is true.  alg - Algorithm for solving the SDEs. Default is \"EM\"   source  #  DifferentialEquations.RosslerSRI     Type .  RosslerSRI  Holds the Butcher tableaus for a Rosser SRI method.  source  #  DifferentialEquations.RosslerSRA     Type .  RosslerSRA  Holds the Butcher tableaus for a Rosser SRA method.  source  #  DifferentialEquations.constructSRA1     Function .  constructSRA1()  Constructs the taleau type for the SRA1 method.  source  #  DifferentialEquations.constructSRIW1     Function .  constructSRIW1()  Constructs the tableau type for the SRIW1 method.  source  #  DifferentialEquations.checkSRAOrder     Function .  checkSRAOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRA method.  source  #  DifferentialEquations.checkSRIOrder     Function .  checkSRIOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRI method.  source", 
            "title": "SDE Solver Extras"
        }, 
        {
            "location": "/internals/solver_helpers/#stationary-stokes", 
            "text": "#  DifferentialEquations.GS\u03b4q!     Function .  GS\u03b4q!(\u03b4q,rp,\u0394xs)  Performs a Gauss-Seidel iteration for \u03b4q.  source  #  DifferentialEquations.GSu!     Function .  GSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)  Performs a Gauss-Seidel iteration on u.  source  #  DifferentialEquations.calc_rp!     Function .  calc_rp!(rp,u,v,\u0394xs,g,px,py)  Calculates the rp from the u and v's.  source  #  DifferentialEquations.update_p!     Function .  update_p!(p,\u03b4q,\u0394xs)  Updates p given \u03b4q  source  #  DifferentialEquations.update_v!     Function .  update_v!(v,\u03b4q,\u0394xs)  Updates v given \u03b4q  source  #  DifferentialEquations.uzawa_p!     Function .  uzawa_p!(p,u,v,\u0394xs,g,px,py)  Solves for p from u and v using an Uzawa update.  source  #  DifferentialEquations.stokes_restriction     Function .  stokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Restricts the Stokes problem to the coarsegrid.  source  #  DifferentialEquations.stokes_prolongation     Function .  stokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Prolongates the Stokes problem to the fine grid  source  #  DifferentialEquations.update_u!     Function .  update_u!(u,\u03b4q,\u0394xs)  Updates u given \u03b4q  source  #  DifferentialEquations.GSv!     Function .  GSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)  Performs a Gauss-Seidel iteration on v.  source", 
            "title": "Stationary Stokes"
        }, 
        {
            "location": "/internals/notes_on_algorithms/", 
            "text": "Notes on Algorithms\n\n\nThis page is a supplemental page which details some facts about the chosen algorithms, why some I took the time to make optimized versions for, and for others why they were ignored.\n\n\n\n\nExplicit Runge-Kutta ODE Algorithms\n\n\nFrom what I can tell, this is by far the most comprehensive comparison of Explicit Runge-Kutta ODE algorithms that you'll find.\n\n\n\n\nImplementations\n\n\nThe different implementations have been benchmarked against each other. The efficiency was calculated by weighing both the time and error on classic test problems. To make clear distinctions, solver options were tweaked to many different settings, including:\n\n\n\n\nMatching errors\n\n\nMatching runtimes\n\n\nMatching settings\n\n\nLow/High tolerance\n\n\n\n\nThe DifferentialEquations.jl implementations of the explicit Runge-Kutta solvers are by a good margin the most efficient implementations of the given algorithms. They utilize many extra tricks, nice caching, and threading if available, to vastly outperform the other methods in terms of efficiency (even with threading disabled). \n:DP5\n performs much better than \n:dopri5\n, which vastly outperform \node45\n (whose stepsize algorithm tends to have issues on some quasi-stiff problems). \n:DP8\n performs better than \ndop853\n which vastly outperforms \node78\n.\n\n\nFor this reason, the DifferentialEquations.jl non-stiff algorithms are the recommended implementations. ODEInterface non-stiff algorithms are only recommended for historical purposes (i.e. to match previous results). The ODE.jl algorithms are not recommended for any serious use (the package is essentially deprecated: it's slow, gets high error, the timestepping algorithm is not robust, and doesn't implement many methods).\n\n\n\n\nOrder 4-\n\n\nAt this stage, coefficient of the truncation error seems to win out, or you are willing to live with low tolerance anyways. Thus Bogacki-Shampine is the clear winner in this category because at order 2/3 with FASL it has minimal numbers of function evaluations but also is stable enough to step as needed. All other methods don't compare because of the FASL property boosting the order and thus the stability (for low orders, it pretty much holds that higher order = higher stability (for optimal number of steps), which is not true as we go higher), making it more stable and have less error for lower numbers of function evaluations than the others in this category.\n\n\n\n\nOrder 5\n\n\n[Note that for all of these Peter Stone's modifications do not seem to be helpful since, although they lower the truncation error, they also modify the stability region in ways that can be worrisome (mostly they shrink the stability in the complex axis near the origin, making the problems not as suitable for a \"general purpose default\" like one would hope with a 4/5 solver)]\n\n\nThe \"clear choice\" is the Dormand-Prince 4/5 pair. This is the pair which is used by default as ode45 in MATLAB, and serves similar functions in scipy, ODE.jl, etc. The golden standard implementation is Hairer's DOPRI5 (offered by ODEInterface.jl). After optimizations, DifferentialEquations.jl's native DP5 solver is much more efficient (between 4x-400x) than DOPRI5's, with various design choices factoring into this (which are documented in the benchmarks). This is pre-threading, and within method threading will likely be at least doubled or tripled when threading is enabled. Thus it's clear that the reference implementation to try other methods against is the DifferentialEquations.jl DP5 method.\n\n\nIt's obvious that anything before Dormand-Prince 4/5's pair is simply not as good because of the optimizations on the local truncation error coefficient and the fact that FASL schemes essentially have one less function evaluation. So the previous algorithms were implemented as tableaus for the historical reasons but dealt with no further. These methods include the Runge, Cassity, Butcher, Fehlburg, Lawson, Luther and Konen, and Kutta schemes.\n\n\nThe next set of schemes are the Papakostas-Papageorgiou schemes. The problem is that they don't really get the much lower on the error than DP5, but also have wacky stability near the origin.\n\n\nTsitouras's looks to be a good match against DP5 as a 6-stage scheme to take on DP5. Its stability is similar to DP5 but its first error term is an order of magnitude smaller. More tests will likely determine that this is much better than DP5 in accordance with his paper.\n\n\nLastly, there are the 7-stage schemes. The more recent one is due to Sharp and Smart, but I am ignoring this because its error term is almost an order of magnitude larger than the BS pair, and its stability reagion is wonky near the origin. Its only plus over the BS pair is that it has a slightly larger stability in the real axis, which is not important when paired with adaptive stepping and for use on non-stiff problems.\n\n\nThat leaves us with the Bogacki-Shampine pair. This pair gets more than an order of magnitude lower truncation error, enhanced complex stability, and two error estimators to make it more robust. In fact, this is the default which is chosen in Mathematica. Its downside is that since it is an 8-stage scheme, it requires an additional function evaluation.\n\n\nFurther tests will likely narrow this down to Tsitouras vs Bogacki-Shampine. Who will come out on top? Who knows.\n\n\n\n\nOrder 6\n\n\nSharp-Verner has bad complex stability near the origin. I don't like any of the Peter Stone modifications here. Butcher and Chummund methods have stability issues near the origin as well. Huta's method has too high of an error coefficient. Verner's 1991 has bad complex stability. Same as the most robust. The Verner \"most efficient\" has really good stability and error coefficient. In fact, nothing is even close except for Tsitouras' method. The DP method is two orders of magnitude higher in error coefficient than Verner. The Luther methods have too much error. Same as Tsitouras-Papakostas and  M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki.\n\n\nWithout a doubt the winner is the Verner \"most efficient\".\n\n\n\n\nOrder 7\n\n\nThe Enright-Verner and other Verner methods all have stability issues near the origin in the complex plane and higher error coefficients. Sharp and Smart have higher error coefficients. Peter Stone's methods all have higher error. It's very clear that the best here is the Tanaka-Yamashita (efficient, not the stable) method by far.\n\n\n\n\nOrder 8\n\n\nThe Cooper-Verner methods do not have an error estimate and so no adaptive timestepping can be done. This is a deal-breaker. Going into this one would think that the clear winner would be Dormand-Prince 8. But that's not the case. However, that's comparing the classical 1981 DP87. Notice that the code for Dop853 is based off of the 1989 paper which has different coefficients (and currently I have no analysis for this).\n\n\nThe other methods include Verner's Maple dverk78 which is bested in both stability and error coefficient by Enright-Verner which is bested by Tsitouras-Papakostas.\n\n\nThus the final showdown is between DP853 vs the Tsitouras-Papakostas pair.\n\n\n\n\nOrder 9\n\n\nThe Tsitouras scheme and the Sharp scheme have funky stability near the origin. Verner's schemes are much safer, and with similar error. They clearly dominate this category.\n\n\n\n\nOrder 10\n\n\nCurtis' scheme has more function evaluations than needed, and Peter Stone's modification reduces the truncation error by a lot but adds three more function evaluations. Thus Hairer's 17 stage scheme (whose error and stability is similar to Curtis') is clearly better. Once again Peter Stone's modification adds three steps but does not reduce the truncation error here, so the unmodified version does better.\n\n\nTom Baker's method increases the stability region to something which is more than necessary but adds 4 function evaluations to do so (without lowering the error very much). Ono's scheme minimizes the error more than Hairer's here, with all else being basically the same. The Peter Stone methods add a lot of function evaluations (5+) and so they would only be useful in the case where the function evaluations are quick yet you still want really small error. Even then I'm not convinced they are better than the other methods, or better than the higher order methods which use less steps. The stability is only okay.\n\n\nThe Feagin scheme is fine, but with more error and less stability than the Hairer scheme. Thus it seems clear that Hairer's method dominates this category. However, that's only because it does not include an error estimate. Feagin's scheme is close in error and stability, but includes an error estimate which can be used for adaptivity, making it the choice in this category.\n\n\n\n\nOrder 11\n\n\nThe order 11 schemes are due to Tom Baker at the University of Teeside. They have a nice sparsity pattern and receive slightly lower truncation error coefficents than the Feagin, but Feagin's dominates by being \"almost order 13\" anyways so while a nice try the order 11 scheme is likely overwhelmed in any case where it would be useful.\n\n\n\n\nOrder 12\n\n\nHere there are the Feagin schemes and Ono's scheme. Ono's scheme gets horrible stability with more error and so it's not in the running. Peter Stone's modifications do not make a substantive change, and where they do they get rid of the nice property that the Feagin 12 method satisfies many of the higher order conditions as well, making it look even higher order on some problems. Thus the standard Feagin 12 seems to win out in this category.\n\n\n\n\nOrder 14\n\n\nIn this category there is just the Feagin. Peter Stone's modification barely changes anything in the analysis so I did not even attempt it.", 
            "title": "Notes on Algorithms"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#notes-on-algorithms", 
            "text": "This page is a supplemental page which details some facts about the chosen algorithms, why some I took the time to make optimized versions for, and for others why they were ignored.", 
            "title": "Notes on Algorithms"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#explicit-runge-kutta-ode-algorithms", 
            "text": "From what I can tell, this is by far the most comprehensive comparison of Explicit Runge-Kutta ODE algorithms that you'll find.", 
            "title": "Explicit Runge-Kutta ODE Algorithms"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#implementations", 
            "text": "The different implementations have been benchmarked against each other. The efficiency was calculated by weighing both the time and error on classic test problems. To make clear distinctions, solver options were tweaked to many different settings, including:   Matching errors  Matching runtimes  Matching settings  Low/High tolerance   The DifferentialEquations.jl implementations of the explicit Runge-Kutta solvers are by a good margin the most efficient implementations of the given algorithms. They utilize many extra tricks, nice caching, and threading if available, to vastly outperform the other methods in terms of efficiency (even with threading disabled).  :DP5  performs much better than  :dopri5 , which vastly outperform  ode45  (whose stepsize algorithm tends to have issues on some quasi-stiff problems).  :DP8  performs better than  dop853  which vastly outperforms  ode78 .  For this reason, the DifferentialEquations.jl non-stiff algorithms are the recommended implementations. ODEInterface non-stiff algorithms are only recommended for historical purposes (i.e. to match previous results). The ODE.jl algorithms are not recommended for any serious use (the package is essentially deprecated: it's slow, gets high error, the timestepping algorithm is not robust, and doesn't implement many methods).", 
            "title": "Implementations"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-4-", 
            "text": "At this stage, coefficient of the truncation error seems to win out, or you are willing to live with low tolerance anyways. Thus Bogacki-Shampine is the clear winner in this category because at order 2/3 with FASL it has minimal numbers of function evaluations but also is stable enough to step as needed. All other methods don't compare because of the FASL property boosting the order and thus the stability (for low orders, it pretty much holds that higher order = higher stability (for optimal number of steps), which is not true as we go higher), making it more stable and have less error for lower numbers of function evaluations than the others in this category.", 
            "title": "Order 4-"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-5", 
            "text": "[Note that for all of these Peter Stone's modifications do not seem to be helpful since, although they lower the truncation error, they also modify the stability region in ways that can be worrisome (mostly they shrink the stability in the complex axis near the origin, making the problems not as suitable for a \"general purpose default\" like one would hope with a 4/5 solver)]  The \"clear choice\" is the Dormand-Prince 4/5 pair. This is the pair which is used by default as ode45 in MATLAB, and serves similar functions in scipy, ODE.jl, etc. The golden standard implementation is Hairer's DOPRI5 (offered by ODEInterface.jl). After optimizations, DifferentialEquations.jl's native DP5 solver is much more efficient (between 4x-400x) than DOPRI5's, with various design choices factoring into this (which are documented in the benchmarks). This is pre-threading, and within method threading will likely be at least doubled or tripled when threading is enabled. Thus it's clear that the reference implementation to try other methods against is the DifferentialEquations.jl DP5 method.  It's obvious that anything before Dormand-Prince 4/5's pair is simply not as good because of the optimizations on the local truncation error coefficient and the fact that FASL schemes essentially have one less function evaluation. So the previous algorithms were implemented as tableaus for the historical reasons but dealt with no further. These methods include the Runge, Cassity, Butcher, Fehlburg, Lawson, Luther and Konen, and Kutta schemes.  The next set of schemes are the Papakostas-Papageorgiou schemes. The problem is that they don't really get the much lower on the error than DP5, but also have wacky stability near the origin.  Tsitouras's looks to be a good match against DP5 as a 6-stage scheme to take on DP5. Its stability is similar to DP5 but its first error term is an order of magnitude smaller. More tests will likely determine that this is much better than DP5 in accordance with his paper.  Lastly, there are the 7-stage schemes. The more recent one is due to Sharp and Smart, but I am ignoring this because its error term is almost an order of magnitude larger than the BS pair, and its stability reagion is wonky near the origin. Its only plus over the BS pair is that it has a slightly larger stability in the real axis, which is not important when paired with adaptive stepping and for use on non-stiff problems.  That leaves us with the Bogacki-Shampine pair. This pair gets more than an order of magnitude lower truncation error, enhanced complex stability, and two error estimators to make it more robust. In fact, this is the default which is chosen in Mathematica. Its downside is that since it is an 8-stage scheme, it requires an additional function evaluation.  Further tests will likely narrow this down to Tsitouras vs Bogacki-Shampine. Who will come out on top? Who knows.", 
            "title": "Order 5"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-6", 
            "text": "Sharp-Verner has bad complex stability near the origin. I don't like any of the Peter Stone modifications here. Butcher and Chummund methods have stability issues near the origin as well. Huta's method has too high of an error coefficient. Verner's 1991 has bad complex stability. Same as the most robust. The Verner \"most efficient\" has really good stability and error coefficient. In fact, nothing is even close except for Tsitouras' method. The DP method is two orders of magnitude higher in error coefficient than Verner. The Luther methods have too much error. Same as Tsitouras-Papakostas and  M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki.  Without a doubt the winner is the Verner \"most efficient\".", 
            "title": "Order 6"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-7", 
            "text": "The Enright-Verner and other Verner methods all have stability issues near the origin in the complex plane and higher error coefficients. Sharp and Smart have higher error coefficients. Peter Stone's methods all have higher error. It's very clear that the best here is the Tanaka-Yamashita (efficient, not the stable) method by far.", 
            "title": "Order 7"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-8", 
            "text": "The Cooper-Verner methods do not have an error estimate and so no adaptive timestepping can be done. This is a deal-breaker. Going into this one would think that the clear winner would be Dormand-Prince 8. But that's not the case. However, that's comparing the classical 1981 DP87. Notice that the code for Dop853 is based off of the 1989 paper which has different coefficients (and currently I have no analysis for this).  The other methods include Verner's Maple dverk78 which is bested in both stability and error coefficient by Enright-Verner which is bested by Tsitouras-Papakostas.  Thus the final showdown is between DP853 vs the Tsitouras-Papakostas pair.", 
            "title": "Order 8"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-9", 
            "text": "The Tsitouras scheme and the Sharp scheme have funky stability near the origin. Verner's schemes are much safer, and with similar error. They clearly dominate this category.", 
            "title": "Order 9"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-10", 
            "text": "Curtis' scheme has more function evaluations than needed, and Peter Stone's modification reduces the truncation error by a lot but adds three more function evaluations. Thus Hairer's 17 stage scheme (whose error and stability is similar to Curtis') is clearly better. Once again Peter Stone's modification adds three steps but does not reduce the truncation error here, so the unmodified version does better.  Tom Baker's method increases the stability region to something which is more than necessary but adds 4 function evaluations to do so (without lowering the error very much). Ono's scheme minimizes the error more than Hairer's here, with all else being basically the same. The Peter Stone methods add a lot of function evaluations (5+) and so they would only be useful in the case where the function evaluations are quick yet you still want really small error. Even then I'm not convinced they are better than the other methods, or better than the higher order methods which use less steps. The stability is only okay.  The Feagin scheme is fine, but with more error and less stability than the Hairer scheme. Thus it seems clear that Hairer's method dominates this category. However, that's only because it does not include an error estimate. Feagin's scheme is close in error and stability, but includes an error estimate which can be used for adaptivity, making it the choice in this category.", 
            "title": "Order 10"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-11", 
            "text": "The order 11 schemes are due to Tom Baker at the University of Teeside. They have a nice sparsity pattern and receive slightly lower truncation error coefficents than the Feagin, but Feagin's dominates by being \"almost order 13\" anyways so while a nice try the order 11 scheme is likely overwhelmed in any case where it would be useful.", 
            "title": "Order 11"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-12", 
            "text": "Here there are the Feagin schemes and Ono's scheme. Ono's scheme gets horrible stability with more error and so it's not in the running. Peter Stone's modifications do not make a substantive change, and where they do they get rid of the nice property that the Feagin 12 method satisfies many of the higher order conditions as well, making it look even higher order on some problems. Thus the standard Feagin 12 seems to win out in this category.", 
            "title": "Order 12"
        }, 
        {
            "location": "/internals/notes_on_algorithms/#order-14", 
            "text": "In this category there is just the Feagin. Peter Stone's modification barely changes anything in the analysis so I did not even attempt it.", 
            "title": "Order 14"
        }
    ]
}